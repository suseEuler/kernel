From 33c4a18f939b279275b2d137e884553f78ff99db Mon Sep 17 00:00:00 2001
From: Chen Wandun <chenwandun@huawei.com>
Date: Fri, 11 Nov 2022 09:32:29 +0800
Subject: [PATCH] mm: Add cmdline for the reliable memory usage of page cache
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 33c4a18f939b279275b2d137e884553f78ff99db
Modified-by-SEL: No


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I4SK3S
CVE: NA

--------------------------------

Add cmdline for the reliable memory usage of page cache.
Page cache will not use reliable memory when passing option
"P" to reliable_debug in cmdline.

Signed-off-by: Chen Wandun <chenwandun@huawei.com>
Reviewed-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 .../admin-guide/kernel-parameters.txt          |  3 ++-
 include/linux/mem_reliable.h                   |  8 ++++++++
 mm/mem_reliable.c                              | 18 ++++++++++++++++--
 3 files changed, 26 insertions(+), 3 deletions(-)

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 4da9cb4dd234..15c7bceb268c 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -4786,9 +4786,10 @@
 			See Documentation/admin-guide/cgroup-v1/cpusets.rst.
 
 	reliable_debug=	[ARM64]
-			Format: []
+			Format: [P]
 			Only works with CONFIG_MEMORY_RELIABLE and
 			"kernelcore=reliable" is configured.
+			P: Page cache does not use the reliable memory.
 
 	reserve=	[KNL,BUGS] Force kernel to ignore I/O ports or memory
 			Format: <base1>,<size1>[,<base2>,<size2>,...]
diff --git a/include/linux/mem_reliable.h b/include/linux/mem_reliable.h
index 7b22229068f1..857881682ea3 100644
--- a/include/linux/mem_reliable.h
+++ b/include/linux/mem_reliable.h
@@ -14,6 +14,7 @@ DECLARE_STATIC_KEY_FALSE(mem_reliable);
 
 extern bool reliable_enabled;
 extern bool shmem_reliable;
+extern bool pagecache_use_reliable_mem;
 
 extern void mem_reliable_init(bool has_unmirrored_mem,
 			      unsigned long *zone_movable_pfn,
@@ -28,6 +29,11 @@ static inline bool mem_reliable_is_enabled(void)
 	return static_branch_likely(&mem_reliable);
 }
 
+static inline bool pagecache_reliable_is_enabled(void)
+{
+	return pagecache_use_reliable_mem;
+}
+
 static inline bool skip_none_movable_zone(gfp_t gfp, struct zoneref *z)
 {
 	if (!mem_reliable_is_enabled())
@@ -52,8 +58,10 @@ static inline bool shmem_reliable_is_enabled(void)
 }
 #else
 #define reliable_enabled 0
+#define pagecache_use_reliable_mem 0
 
 static inline bool mem_reliable_is_enabled(void) { return false; }
+static inline bool pagecache_reliable_is_enabled(void) { return false; }
 static inline void mem_reliable_init(bool has_unmirrored_mem,
 				     unsigned long *zone_movable_pfn,
 				     unsigned long mirrored_sz) {}
diff --git a/mm/mem_reliable.c b/mm/mem_reliable.c
index e1b6a1002933..5d75ab6482db 100644
--- a/mm/mem_reliable.c
+++ b/mm/mem_reliable.c
@@ -16,6 +16,7 @@ EXPORT_SYMBOL_GPL(mem_reliable);
 
 bool reliable_enabled;
 bool shmem_reliable __read_mostly = true;
+bool pagecache_use_reliable_mem __read_mostly = true;
 
 bool mem_reliable_status(void)
 {
@@ -25,8 +26,17 @@ EXPORT_SYMBOL_GPL(mem_reliable_status);
 
 void page_cache_prepare_alloc(gfp_t *gfp)
 {
-	if (mem_reliable_is_enabled())
-		*gfp |= GFP_RELIABLE;
+	if (!mem_reliable_is_enabled())
+		return;
+
+	if (!pagecache_reliable_is_enabled())
+		goto no_reliable;
+
+	*gfp |= GFP_RELIABLE;
+	return;
+
+no_reliable:
+	*gfp &= ~GFP_RELIABLE;
 }
 
 static unsigned long total_reliable_pages(void)
@@ -121,6 +131,10 @@ static int __init setup_reliable_debug(char *str)
 	 */
 	for (; *str && *str != ','; str++) {
 		switch (*str) {
+		case 'P':
+			pagecache_use_reliable_mem = false;
+			pr_info("disable page cache use reliable memory\n");
+			break;
 		default:
 			pr_err("reliable_debug option '%c' unknown. skipped\n",
 			       *str);
-- 
2.33.0

