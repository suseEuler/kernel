From 2973c579acc563e8c95fd8ca09ee0d1af4ea1696 Mon Sep 17 00:00:00 2001
From: Mao Minkai <maominkai@wxiat.com>
Date: Wed, 31 Aug 2022 17:06:56 +0800
Subject: [PATCH] sw64: bpf: fix 32-bit bitwise operation
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 2973c579acc563e8c95fd8ca09ee0d1af4ea1696
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5PNI5

--------------------------------

Make sure the result of 32-bit bitwise operation is zero extended to
64 bits.

Signed-off-by: Mao Minkai <maominkai@wxiat.com>
Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/net/bpf_jit_comp.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/arch/sw_64/net/bpf_jit_comp.c b/arch/sw_64/net/bpf_jit_comp.c
index 10fc58eb4d37..5e3d8d5327d3 100644
--- a/arch/sw_64/net/bpf_jit_comp.c
+++ b/arch/sw_64/net/bpf_jit_comp.c
@@ -745,14 +745,23 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)
 		emit(SW64_BPF_SRA_REG(dst, src, dst), ctx);
 		break;
 	case BPF_ALU | BPF_AND | BPF_X:
+		emit(SW64_BPF_AND_REG(dst, src, dst), ctx);
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
+		break;
 	case BPF_ALU64 | BPF_AND | BPF_X:
 		emit(SW64_BPF_AND_REG(dst, src, dst), ctx);
 		break;
 	case BPF_ALU | BPF_OR | BPF_X:
+		emit(SW64_BPF_BIS_REG(dst, src, dst), ctx);
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
+		break;
 	case BPF_ALU64 | BPF_OR | BPF_X:
 		emit(SW64_BPF_BIS_REG(dst, src, dst), ctx);
 		break;
 	case BPF_ALU | BPF_XOR | BPF_X:
+		emit(SW64_BPF_XOR_REG(dst, src, dst), ctx);
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
+		break;
 	case BPF_ALU64 | BPF_XOR | BPF_X:
 		emit(SW64_BPF_XOR_REG(dst, src, dst), ctx);
 		break;
@@ -936,6 +945,7 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)
 			emit_sw64_ldu32(tmp1, imm, ctx);
 			emit(SW64_BPF_AND_REG(dst, tmp1, dst), ctx);
 		}
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
 		break;
 	case BPF_ALU64 | BPF_AND | BPF_K:
 		if (imm >= 0 && imm <= U8_MAX) {
@@ -952,6 +962,7 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)
 			emit_sw64_ldu32(tmp1, imm, ctx);
 			emit(SW64_BPF_BIS_REG(dst, tmp1, dst), ctx);
 		}
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
 		break;
 	case BPF_ALU64 | BPF_OR | BPF_K:
 		if (imm >= 0 && imm <= U8_MAX) {
@@ -968,6 +979,7 @@ static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)
 			emit_sw64_ldu32(tmp1, imm, ctx);
 			emit(SW64_BPF_XOR_REG(dst, tmp1, dst), ctx);
 		}
+		emit(SW64_BPF_ZAP_IMM(dst, 0xf0, dst), ctx);
 		break;
 	case BPF_ALU64 | BPF_XOR | BPF_K:
 		if (imm >= 0 && imm <= U8_MAX) {
-- 
2.33.0

