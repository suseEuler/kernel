From c6b10d92003852305d90eeace9b16c2b26735da3 Mon Sep 17 00:00:00 2001
From: Mao Minkai <maominkai@wxiat.com>
Date: Wed, 26 Oct 2022 14:12:14 +0800
Subject: [PATCH] sw64: remove unused boot syncronization code
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: c6b10d92003852305d90eeace9b16c2b26735da3
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I56OLG

--------------------------------

There's no need to do syncronization between boot core and secondary
core during smp booting on SW64. Remove the redundant code.

Signed-off-by: Mao Minkai <maominkai@wxiat.com>
Reviewed-by: He Sheng <hesheng@wxiat.com>
Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/kernel/smp.c | 62 +----------------------------------------
 1 file changed, 1 insertion(+), 61 deletions(-)

diff --git a/arch/sw_64/kernel/smp.c b/arch/sw_64/kernel/smp.c
index ecf276e9e364..79dc334c3375 100644
--- a/arch/sw_64/kernel/smp.c
+++ b/arch/sw_64/kernel/smp.c
@@ -50,31 +50,12 @@ enum ipi_message_type {
 	IPI_CPU_STOP,
 };
 
-/* Set to a secondary's cpuid when it comes online.  */
-static int smp_secondary_alive;
-
 int smp_num_cpus = 1;		/* Number that came online.  */
 EXPORT_SYMBOL(smp_num_cpus);
 
 #define send_sleep_interrupt(cpu)	send_ipi((cpu), II_SLEEP)
 #define send_wakeup_interrupt(cpu)	send_ipi((cpu), II_WAKE)
 
-
-static void __init wait_boot_cpu_to_stop(int cpuid)
-{
-	unsigned long stop = jiffies + 10*HZ;
-
-	while (time_before(jiffies, stop)) {
-		if (!smp_secondary_alive)
-			return;
-		barrier();
-	}
-
-	printk("%s: FAILED on CPU %d, hanging now\n", __func__, cpuid);
-	for (;;)
-		barrier();
-}
-
 void __weak enable_chip_int(void) { }
 
 /*
@@ -122,16 +103,6 @@ void smp_callin(void)
 	/* Must have completely accurate bogos.  */
 	local_irq_enable();
 
-	/* Wait boot CPU to stop with irq enabled before running
-	 * calibrate_delay.
-	 */
-	wait_boot_cpu_to_stop(cpuid);
-	mb();
-
-	/* Allow master to continue only after we written loops_per_jiffy.  */
-	wmb();
-	smp_secondary_alive = 1;
-
 	DBGS("%s: commencing CPU %d (RCID: %d)current %p active_mm %p\n",
 		__func__, cpuid, cpu_to_rcid(cpuid), current, current->active_mm);
 
@@ -191,40 +162,9 @@ static int secondary_cpu_start(int cpuid, struct task_struct *idle)
  */
 static int smp_boot_one_cpu(int cpuid, struct task_struct *idle)
 {
-	unsigned long timeout;
-
-	/* Signal the secondary to wait a moment.  */
-	smp_secondary_alive = -1;
-
 	per_cpu(cpu_state, cpuid) = CPU_UP_PREPARE;
 
-	/* Whirrr, whirrr, whirrrrrrrrr... */
-	if (secondary_cpu_start(cpuid, idle))
-		return -1;
-
-	/* Notify the secondary CPU it can run calibrate_delay.  */
-	mb();
-	smp_secondary_alive = 0;
-
-	/* We've been acked by the console; wait one second for
-	 * the task to start up for real.
-	 */
-	timeout = jiffies + 1*HZ;
-	while (time_before(jiffies, timeout)) {
-		if (smp_secondary_alive == 1)
-			goto alive;
-		udelay(10);
-		barrier();
-	}
-
-	/* We failed to boot the CPU.  */
-
-	pr_err("SMP: Processor %d is stuck.\n", cpuid);
-	return -1;
-
-alive:
-	/* Another "Red Snapper". */
-	return 0;
+	return secondary_cpu_start(cpuid, idle);
 }
 
 static void __init process_nr_cpu_ids(void)
-- 
2.33.0

