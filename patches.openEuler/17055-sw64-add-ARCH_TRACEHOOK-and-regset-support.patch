From 06ed664fca7dcb8963d9868472a4cbbb149edb27 Mon Sep 17 00:00:00 2001
From: Gu Zitao <guzitao@wxiat.com>
Date: Tue, 24 May 2022 15:28:27 +0800
Subject: [PATCH] sw64: add ARCH_TRACEHOOK and regset support
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 06ed664fca7dcb8963d9868472a4cbbb149edb27
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5G7NL

--------------------------------

By adding TRACEHOOK support, we can access register sets via
PTRACE_GETREGSET and PTRACE_SETREGSET request.

The user-visible regset struct user_pt_regs and user_fpsimd_state
are added in this patch, and they can be accessed with NT_PRSTATUS
and NT_PRFPREG respectively.

Besides, PTRACE_{GET,SET}REGS and PTRACE_{GET,SET}FPREGS requests
which are implemented in error have never been used on sw64, so we
remove them completely.

Signed-off-by: Gu Zitao <guzitao@wxiat.com>

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/Kconfig                   |   1 +
 arch/sw_64/include/uapi/asm/ptrace.h |  18 ++-
 arch/sw_64/kernel/ptrace.c           | 194 +++++++++++++--------------
 3 files changed, 111 insertions(+), 102 deletions(-)

diff --git a/arch/sw_64/Kconfig b/arch/sw_64/Kconfig
index 2d7721acb529..0e32fc7e1f9a 100644
--- a/arch/sw_64/Kconfig
+++ b/arch/sw_64/Kconfig
@@ -68,6 +68,7 @@ config SW64
 	select ARCH_HAS_SG_CHAIN
 	select IRQ_FORCED_THREADING
 	select GENERIC_IRQ_MIGRATION if SMP
+	select HAVE_ARCH_TRACEHOOK
 	select HAVE_FUNCTION_TRACER
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_FTRACE_MCOUNT_RECORD
diff --git a/arch/sw_64/include/uapi/asm/ptrace.h b/arch/sw_64/include/uapi/asm/ptrace.h
index ac7ce6b6510b..1169d87c4b9c 100644
--- a/arch/sw_64/include/uapi/asm/ptrace.h
+++ b/arch/sw_64/include/uapi/asm/ptrace.h
@@ -2,10 +2,20 @@
 #ifndef _UAPI_ASM_SW64_PTRACE_H
 #define _UAPI_ASM_SW64_PTRACE_H
 
-#define PTRACE_GETREGS		12	/* get general purpose registers */
-#define PTRACE_SETREGS		13	/* set general purpose registers */
-#define PTRACE_GETFPREGS	14	/* get floating-point registers */
-#define PTRACE_SETFPREGS	15	/* set floating-point registers */
+/*
+ * User structures for general purpose, floating point and debug registers.
+ */
+struct user_pt_regs {
+	__u64 regs[31];
+	__u64 pc;
+	__u64 pstate;
+};
+
+struct user_fpsimd_state {
+	__u64 vregs[124];
+	__u64 fpcr;
+};
+
 /* PTRACE_ATTACH is 16 */
 /* PTRACE_DETACH is 17 */
 
diff --git a/arch/sw_64/kernel/ptrace.c b/arch/sw_64/kernel/ptrace.c
index 94809804e23e..94fba3569781 100644
--- a/arch/sw_64/kernel/ptrace.c
+++ b/arch/sw_64/kernel/ptrace.c
@@ -7,6 +7,8 @@
 
 #include <linux/tracehook.h>
 #include <linux/audit.h>
+#include <linux/regset.h>
+#include <linux/elf.h>
 
 #include <asm/reg.h>
 #include <asm/asm-offsets.h>
@@ -270,123 +272,131 @@ void ptrace_disable(struct task_struct *child)
 	user_disable_single_step(child);
 }
 
-int ptrace_getregs(struct task_struct *child, __s64 __user *data)
+static int gpr_get(struct task_struct *target,
+			const struct user_regset *regset,
+			struct membuf to)
 {
-	int ret, retval = 0;
-	int i;
-	unsigned long regval;
+	struct pt_regs *regs;
+	struct user_pt_regs uregs;
+	int i, ret;
 
-	if (!access_ok(data, sizeof(long) * 33))
-		return -EIO;
+	regs = task_pt_regs(target);
+	for (i = 0; i < 30; i++)
+		uregs.regs[i] = *(__u64 *)((void *)regs + regoffsets[i]);
+
+	uregs.regs[30] = task_thread_info(target)->pcb.usp;
+	uregs.pc = regs->pc;
+	uregs.pstate = regs->ps;
+
+	ret = membuf_write(&to, &uregs, sizeof(uregs));
 
-	/* r0-r15 */
-	for (i = 0; i < 16; i++) {
-		regval = get_reg(child, i);
-		retval |= __put_user((long)regval, data + i);
-	}
-	/* r19-r28 */
-	for (i = 19; i < 29; i++) {
-		regval = get_reg(child, i);
-		retval |= __put_user((long)regval, data + i - 3);
-	}
-	/*SP, PS ,PC,GP*/
-	retval |= __put_user((long)(get_reg(child, REG_SP)), data + EF_SP);
-	retval |= __put_user((long)(get_reg(child, REG_PS)), data + EF_PS);
-	retval |= __put_user((long)(get_reg(child, REG_PC)), data + EF_PC);
-	retval |= __put_user((long)(get_reg(child, REG_GP)), data + EF_GP);
-	/* r16-r18 */
-	retval |= __put_user((long)(get_reg(child, 16)), data + EF_A0);
-	retval |= __put_user((long)(get_reg(child, 17)), data + EF_A1);
-	retval |= __put_user((long)(get_reg(child, 18)), data + EF_A2);
-
-	ret = retval ? -EIO : 0;
 	return ret;
 }
 
-int ptrace_setregs(struct task_struct *child, __s64 __user *data)
+static int gpr_set(struct task_struct *target,
+			const struct user_regset *regset,
+			unsigned int pos, unsigned int count,
+			const void *kbuf, const void __user *ubuf)
 {
-	int ret, retval = 0;
-	int i;
-	unsigned long regval;
+	struct pt_regs *regs;
+	struct user_pt_regs uregs;
+	int i, ret;
 
-	if (!access_ok(data, sizeof(long) * 33))
-		return -EIO;
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				&uregs, 0, sizeof(uregs));
+	if (ret)
+		return ret;
+
+	regs = task_pt_regs(target);
+	for (i = 0; i < 30; i++)
+		*(__u64 *)((void *)regs + regoffsets[i]) = uregs.regs[i];
+
+	task_thread_info(target)->pcb.usp = uregs.regs[30];
+	regs->pc = uregs.pc;
+	regs->ps = uregs.pstate;
 
-	/* r0-r15 */
-	for (i = 0; i < 16; i++) {
-		retval |= __get_user(regval, data + i);
-		ret = put_reg(child, i, regval);
-	}
-	/* r19-r28 */
-	for (i = 19; i < 29; i++) {
-		retval |= __get_user(regval, data + i - 3);
-		ret = put_reg(child, i, regval);
-	}
-	/*SP, PS ,PC,GP*/
-	retval |= __get_user(regval, data + EF_SP);
-	ret = put_reg(child, REG_SP, regval);
-	retval |= __get_user(regval, data + EF_PS);
-	ret = put_reg(child, REG_PS, regval);
-	retval |= __get_user(regval, data + EF_PC);
-	ret = put_reg(child, REG_PC, regval);
-	retval |= __get_user(regval, data + EF_GP);
-	ret = put_reg(child, REG_GP, regval);
-	/* r16-r18 */
-	retval |= __get_user(regval, data + EF_A0);
-	ret = put_reg(child, 16, regval);
-	retval |= __get_user(regval, data + EF_A1);
-	ret = put_reg(child, 17, regval);
-	retval |= __get_user(regval, data + EF_A2);
-	ret = put_reg(child, 18, regval);
-
-	ret = retval ? -EIO : 0;
 	return 0;
 }
 
-int ptrace_getfpregs(struct task_struct *child, __s64 __user *data)
+static int fpr_get(struct task_struct *target,
+			const struct user_regset *regset,
+			struct membuf to)
 {
-	int ret, retval = 0;
-	int i;
-	unsigned long regval;
+	int ret;
+	struct user_fpsimd_state uregs;
 
-	if (!access_ok(data, sizeof(long) * 32))
-		return -EIO;
+	memcpy(uregs.vregs, &target->thread.ctx_fp,
+			sizeof(struct context_fpregs));
 
-	/* fp0-fp31 */
-	for (i = 0; i < 32; i++) {
-		regval = get_reg(child, REG_F0 + i);
-		retval |= __put_user((long)regval, data + i);
-	}
+	uregs.fpcr = target->thread.fpcr;
 
-	ret = retval ? -EIO : 0;
-	return 0;
+	ret = membuf_write(&to, &uregs, sizeof(uregs));
+
+	return ret;
 }
 
-int ptrace_setfpregs(struct task_struct *child, __s64 __user *data)
+static int fpr_set(struct task_struct *target,
+			const struct user_regset *regset,
+			unsigned int pos, unsigned int count,
+			const void *kbuf, const void __user *ubuf)
 {
-	int ret, retval = 0;
-	int i;
-	unsigned long regval;
+	int ret;
+	struct user_fpsimd_state uregs;
 
-	if (!access_ok(data, sizeof(long) * 32))
-		return -EIO;
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				&uregs, 0, sizeof(uregs));
 
-	/* fp0-fp31 */
-	for (i = 0; i < 32; i++) {
-		retval |= __get_user(regval, data + i);
-		ret = put_reg(child, REG_F0 + i, regval);
-	}
+	if (ret)
+		return ret;
+
+	memcpy(&target->thread.ctx_fp, uregs.vregs,
+			sizeof(struct context_fpregs));
+
+	target->thread.fpcr = uregs.fpcr;
 
 	return ret;
 }
 
+enum sw64_regset {
+	REGSET_GPR,
+	REGSET_FPR,
+};
+
+static const struct user_regset sw64_regsets[] = {
+	[REGSET_GPR] = {
+		.core_note_type = NT_PRSTATUS,
+		.n = ELF_NGREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.regset_get = gpr_get,
+		.set = gpr_set
+	},
+	[REGSET_FPR] = {
+		.core_note_type = NT_PRFPREG,
+		.n = sizeof(struct user_fpsimd_state) / sizeof(u64),
+		.size = sizeof(u64),
+		.align = sizeof(u64),
+		.regset_get = fpr_get,
+		.set = fpr_set
+	},
+};
+
+static const struct user_regset_view user_sw64_view = {
+	.name = "sw64", .e_machine = EM_SW64,
+	.regsets = sw64_regsets, .n = ARRAY_SIZE(sw64_regsets)
+};
+
+const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+{
+	return &user_sw64_view;
+}
+
 long arch_ptrace(struct task_struct *child, long request,
 		unsigned long addr, unsigned long data)
 {
 	unsigned long tmp;
 	size_t copied;
 	long ret;
-	void __user *datavp = (void __user *) data;
 
 	switch (request) {
 	/* When I and D space are separate, these will need to be fixed.  */
@@ -416,18 +426,6 @@ long arch_ptrace(struct task_struct *child, long request,
 	case PTRACE_POKEUSR: /* write the specified register */
 		ret = put_reg(child, addr, data);
 		break;
-	case PTRACE_GETREGS:
-		ret = ptrace_getregs(child, datavp);
-		break;
-	case PTRACE_SETREGS:
-		ret = ptrace_setregs(child, datavp);
-		break;
-	case PTRACE_GETFPREGS:
-		ret = ptrace_getfpregs(child, datavp);
-		break;
-	case PTRACE_SETFPREGS:
-		ret = ptrace_setfpregs(child, datavp);
-		break;
 	default:
 		ret = ptrace_request(child, request, addr, data);
 		break;
-- 
2.33.0

