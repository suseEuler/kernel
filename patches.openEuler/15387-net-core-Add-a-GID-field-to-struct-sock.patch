From f6740a11189620e5fd5ec0642c41b00f71b01689 Mon Sep 17 00:00:00 2001
From: Lu Wei <luwei32@huawei.com>
Date: Tue, 10 May 2022 23:05:02 +0800
Subject: [PATCH] net: core: Add a GID field to struct sock.
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: f6740a11189620e5fd5ec0642c41b00f71b01689
Modified-by-SEL: Yes, modfied due to different context


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I545NW
CVE: NA

--------------------------------

UID and GID are requested as filters for socketmap, but we can only get
UID from sock structure. This patch adds GID field to struct sock as UID.

Signed-off-by: Lu Wei <luwei32@huawei.com>
Signed-off-by: Liu Jian <liujian56@huawei.com>
Reviewed-by: Wei Yongjun <weiyongjun1@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 include/net/sock.h |   14 ++++++++++++++
 net/core/sock.c    |    2 ++
 net/socket.c       |    6 ++++--
 3 files changed, 20 insertions(+), 2 deletions(-)

--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -300,6 +300,7 @@ struct bpf_local_storage;
   *	@sk_ack_backlog: current listen backlog
   *	@sk_max_ack_backlog: listen backlog set in listen()
   *	@sk_uid: user id of owner
+  *	@sk_gid: group id of owner
   *	@sk_prefer_busy_poll: prefer busypolling over softirq processing
   *	@sk_busy_poll_budget: napi processing budget when busypolling
   *	@sk_priority: %SO_PRIORITY setting
@@ -535,7 +536,14 @@ struct sock {
 #endif
 	struct rcu_head		sk_rcu;
 
+#ifndef __GENKSYMS__
+	union {
+		kgid_t	sk_gid;
+		u64	sk_gid_padding;
+	};
+#else
 	KABI_RESERVE(1)
+#endif
 	KABI_RESERVE(2)
 	KABI_RESERVE(3)
 	KABI_RESERVE(4)
@@ -2048,6 +2056,7 @@ static inline void sock_graft(struct soc
 	parent->sk = sk;
 	sk_set_socket(sk, parent);
 	sk->sk_uid = SOCK_INODE(parent)->i_uid;
+	sk->sk_gid = SOCK_INODE(parent)->i_gid;
 	security_sock_graft(sk, parent);
 	write_unlock_bh(&sk->sk_callback_lock);
 }
@@ -2060,6 +2069,11 @@ static inline kuid_t sock_net_uid(const
 	return sk ? sk->sk_uid : make_kuid(net->user_ns, 0);
 }
 
+static inline kgid_t sock_net_gid(const struct net *net, const struct sock *sk)
+{
+	return sk ? sk->sk_gid : make_kgid(net->user_ns, 0);
+}
+
 static inline u32 net_tx_rndhash(void)
 {
 	u32 v = prandom_u32();
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -3086,9 +3086,11 @@ void sock_init_data(struct socket *sock,
 		RCU_INIT_POINTER(sk->sk_wq, &sock->wq);
 		sock->sk	=	sk;
 		sk->sk_uid	=	SOCK_INODE(sock)->i_uid;
+		sk->sk_gid	=	SOCK_INODE(sock)->i_gid;
 	} else {
 		RCU_INIT_POINTER(sk->sk_wq, NULL);
 		sk->sk_uid	=	make_kuid(sock_net(sk)->user_ns, 0);
+		sk->sk_gid	=	make_kgid(sock_net(sk)->user_ns, 0);
 	}
 
 	rwlock_init(&sk->sk_callback_lock);
--- a/net/socket.c
+++ b/net/socket.c
@@ -546,10 +546,12 @@ static int sockfs_setattr(struct dentry
 	if (!err && (iattr->ia_valid & ATTR_UID)) {
 		struct socket *sock = SOCKET_I(d_inode(dentry));
 
-		if (sock->sk)
+		if (sock->sk) {
 			sock->sk->sk_uid = iattr->ia_uid;
-		else
+			sock->sk->sk_gid = iattr->ia_gid;
+		} else {
 			err = -ENOENT;
+		}
 	}
 
 	return err;
