From b66ae5ce5e1329fedcf6a1142df087d496a87398 Mon Sep 17 00:00:00 2001
From: Jian Shen <shenjian15@huawei.com>
Date: Wed, 30 Nov 2022 18:23:34 +0800
Subject: [PATCH] net: hns3: allocate fd counter for queue bonding
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: b66ae5ce5e1329fedcf6a1142df087d496a87398
Modified-by-SEL: No


driver inclusion
category:feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I62HX2

----------------------------------------------------------------------

For the fd rule of queue bonding is created by hardware
automatically, the driver needs to specify the fd counter
for each function, then it's available to query how many
times the queue bonding fd rules hit.

Signed-off-by: Jian Shen <shenjian15@huawei.com>
Signed-off-by: Jiantao Xiao <xiaojiantao1@h-partners.com>
Reviewed-by: Yue Haibing <yuehaibing@huawei.com>
Reviewed-by: Jian Shen <shenjian15@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 .../hisilicon/hns3/hns3pf/hclge_cmd.h         | 12 ++++++
 .../hisilicon/hns3/hns3pf/hclge_main.c        | 39 +++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
index 84cf0c9dd551..eee9a1082894 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.h
@@ -755,6 +755,18 @@ struct hclge_fd_qb_cfg_cmd {
 	u8 rsv[22];
 };
 
+#define HCLGE_FD_QB_AD_RULE_ID_VLD_B	0
+#define HCLGE_FD_QB_AD_COUNTER_VLD_B	1
+struct hclge_fd_qb_ad_cmd {
+	u8 vf_id;
+	u8 rsv1;
+	u8 ad_sel;
+	u8 rsv2;
+	__le16 hit_rule_id;
+	u8 counter_id;
+	u8 rsv3[17];
+};
+
 #define HCLGE_FD_USER_DEF_OFT_S		0
 #define HCLGE_FD_USER_DEF_OFT_M		GENMASK(14, 0)
 #define HCLGE_FD_USER_DEF_EN_B		15
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index fa15471737fe..afac6036a748 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -4561,6 +4561,40 @@ static void hclge_update_vport_alive(struct hclge_dev *hdev)
 	}
 }
 
+static int hclge_set_fd_qb_counter(struct hclge_dev *hdev, u8 vf_id)
+{
+	struct hclge_fd_qb_ad_cmd *req;
+	struct hclge_desc desc;
+	int ret;
+
+	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_FD_QB_AD_OP, false);
+	req = (struct hclge_fd_qb_ad_cmd *)desc.data;
+	req->vf_id = vf_id;
+	hnae3_set_bit(req->ad_sel, HCLGE_FD_QB_AD_COUNTER_VLD_B, 1);
+	req->counter_id = vf_id % hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1];
+	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
+	if (ret)
+		dev_warn(&hdev->pdev->dev,
+			 "failed to set qb counter for vport %u, ret = %d.\n",
+			 vf_id, ret);
+	return ret;
+}
+
+static void hclge_init_fd_qb_counter(struct hclge_dev *hdev)
+{
+	int ret;
+	u16 i;
+
+	if (!test_bit(HNAE3_DEV_SUPPORT_QB_B, hdev->ae_dev->caps))
+		return;
+
+	for (i = 0; i < hdev->num_alloc_vport; i++) {
+		ret = hclge_set_fd_qb_counter(hdev, i);
+		if (ret)
+			return;
+	}
+}
+
 static int hclge_set_fd_qb(struct hclge_dev *hdev, u8 vf_id, bool enable)
 {
 	struct hclge_fd_qb_cfg_cmd *req;
@@ -5682,6 +5716,11 @@ static int hclge_init_fd_config(struct hclge_dev *hdev)
 	if (ret)
 		return ret;
 
+	if (!hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1])
+		hdev->fd_cfg.cnt_num[HCLGE_FD_STAGE_1] = 1;
+
+	hclge_init_fd_qb_counter(hdev);
+
 	return hclge_set_fd_key_config(hdev, HCLGE_FD_STAGE_1);
 }
 
-- 
2.33.0

