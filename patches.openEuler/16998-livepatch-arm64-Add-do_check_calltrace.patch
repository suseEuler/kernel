From ca56aaafcc89c4178ca498b93e51cfb900486053 Mon Sep 17 00:00:00 2001
From: Yang Jihong <yangjihong1@huawei.com>
Date: Wed, 6 Jul 2022 18:05:26 +0800
Subject: [PATCH] livepatch/arm64: Add do_check_calltrace
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: ca56aaafcc89c4178ca498b93e51cfb900486053
Modified-by-SEL: No


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5CJ7X

--------------------------------

The calltrace check code is independent as do_check_calltrace,
for calltrace check of klp module.
No functional change.

Signed-off-by: Yang Jihong <yangjihong1@huawei.com>
Reviewed-by: Xu Kuohai <xukuohai@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/arm64/kernel/livepatch.c | 56 +++++++++++++++++++----------------
 1 file changed, 31 insertions(+), 25 deletions(-)

diff --git a/arch/arm64/kernel/livepatch.c b/arch/arm64/kernel/livepatch.c
index 508a43ce18ca..539d6534a220 100644
--- a/arch/arm64/kernel/livepatch.c
+++ b/arch/arm64/kernel/livepatch.c
@@ -255,23 +255,11 @@ static void free_list(struct klp_func_list **funcs)
 	}
 }
 
-int klp_check_calltrace(struct klp_patch *patch, int enable)
+static int do_check_calltrace(struct walk_stackframe_args *args,
+			      bool (*fn)(void *, unsigned long))
 {
 	struct task_struct *g, *t;
 	struct stackframe frame;
-	int ret = 0;
-	struct klp_func_list *check_funcs = NULL;
-	struct walk_stackframe_args args = {
-		.enable = enable,
-		.ret = 0
-	};
-
-	ret = klp_check_activeness_func(patch, enable, &check_funcs);
-	if (ret) {
-		pr_err("collect active functions failed, ret=%d\n", ret);
-		goto out;
-	}
-	args.check_funcs = check_funcs;
 
 	for_each_process_thread(g, t) {
 		/*
@@ -284,7 +272,7 @@ int klp_check_calltrace(struct klp_patch *patch, int enable)
 		if (t == current) {
 			/* current on this CPU */
 			frame.fp = (unsigned long)__builtin_frame_address(0);
-			frame.pc = (unsigned long)klp_check_calltrace;
+			frame.pc = (unsigned long)do_check_calltrace;
 		} else if (strncmp(t->comm, "migration/", 10) == 0) {
 			/*
 			 * current on other CPU
@@ -293,25 +281,43 @@ int klp_check_calltrace(struct klp_patch *patch, int enable)
 			 * task_comm here, because we can't get the
 			 * cpu_curr(task_cpu(t))). This assumes that no
 			 * other thread will pretend to be a stopper via
-			 * task_comm.Â 
+			 * task_comm.
 			 */
 			continue;
 		} else {
 			frame.fp = thread_saved_fp(t);
 			frame.pc = thread_saved_pc(t);
 		}
-		if (check_funcs != NULL) {
-			start_backtrace(&frame, frame.fp, frame.pc);
-			walk_stackframe(t, &frame, klp_check_jump_func, &args);
-			if (args.ret) {
-				ret = args.ret;
-				pr_info("PID: %d Comm: %.20s\n", t->pid, t->comm);
-				show_stack(t, NULL, KERN_INFO);
-				goto out;
-			}
+		start_backtrace(&frame, frame.fp, frame.pc);
+		walk_stackframe(t, &frame, fn, args);
+		if (args->ret) {
+			pr_info("PID: %d Comm: %.20s\n", t->pid, t->comm);
+			show_stack(t, NULL, KERN_INFO);
+			return args->ret;
 		}
 	}
+	return 0;
+}
+
+int klp_check_calltrace(struct klp_patch *patch, int enable)
+{
+	int ret = 0;
+	struct klp_func_list *check_funcs = NULL;
+	struct walk_stackframe_args args = {
+		.enable = enable,
+		.ret = 0
+	};
+
+	ret = klp_check_activeness_func(patch, enable, &check_funcs);
+	if (ret) {
+		pr_err("collect active functions failed, ret=%d\n", ret);
+		goto out;
+	}
+	if (!check_funcs)
+		goto out;
 
+	args.check_funcs = check_funcs;
+	ret = do_check_calltrace(&args, klp_check_jump_func);
 out:
 	free_list(&check_funcs);
 	return ret;
-- 
2.33.0

