From 53003aee7c6a44a565254b702fe73a0c44fa244b Mon Sep 17 00:00:00 2001
From: He Sheng <hesheng@wxiat.com>
Date: Thu, 12 May 2022 14:07:00 +0800
Subject: [PATCH] sw64: access IO space with readX/writeX
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 53003aee7c6a44a565254b702fe73a0c44fa244b
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5G5YB

--------------------------------

It's more standard to access IO registers by calling readX/writeX
interfaces. In addition, the code is easier to maintain.

Signed-off-by: He Sheng <hesheng@wxiat.com>

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/chip/chip3/i2c-lib.c | 15 +++++--------
 arch/sw_64/include/asm/sw64io.h | 37 ++++++++-------------------------
 2 files changed, 14 insertions(+), 38 deletions(-)

diff --git a/arch/sw_64/chip/chip3/i2c-lib.c b/arch/sw_64/chip/chip3/i2c-lib.c
index b3dcdcd32735..e70f0f0c9a56 100644
--- a/arch/sw_64/chip/chip3/i2c-lib.c
+++ b/arch/sw_64/chip/chip3/i2c-lib.c
@@ -118,19 +118,14 @@ void __iomem *get_i2c_bar_addr(uint8_t i2c_controller_index)
 	}
 }
 
-void write_cpu_i2c_controller(uint64_t offset, uint32_t data)
+static inline void write_cpu_i2c_controller(uint64_t offset, uint32_t data)
 {
-	mb();
-	*(volatile uint32_t *)(m_i2c_base_address + offset) = data;
+	writel(data, m_i2c_base_address + offset);
 }
 
-uint32_t read_cpu_i2c_controller(uint64_t offset)
+static inline uint32_t read_cpu_i2c_controller(uint64_t offset)
 {
-	uint32_t data;
-
-	data = *(volatile uint32_t *)(m_i2c_base_address + offset);
-	mb();
-	return data;
+	return readl(m_i2c_base_address + offset);
 }
 
 static int poll_for_status_set0(uint16_t status_bit)
@@ -241,7 +236,7 @@ static int i2c_read(uint8_t reg_offset, uint8_t *buffer, uint32_t length)
 			write_cpu_i2c_controller(DW_IC_DATA_CMD, DW_IC_CMD);
 
 		if (poll_for_status_set0(DW_IC_STATUS_RFNE) == 0)
-			buffer[i] = *(uint8_t *) (m_i2c_base_address + DW_IC_DATA_CMD);
+			buffer[i] = readb(m_i2c_base_address + DW_IC_DATA_CMD);
 		else
 			pr_err("Read timeout line %d.\n", __LINE__);
 	}
diff --git a/arch/sw_64/include/asm/sw64io.h b/arch/sw_64/include/asm/sw64io.h
index e66aba66932b..7d79a5b75090 100644
--- a/arch/sw_64/include/asm/sw64io.h
+++ b/arch/sw_64/include/asm/sw64io.h
@@ -2,6 +2,7 @@
 #ifndef _ASM_SW64_SW64IO_H
 #define _ASM_SW64_SW64IO_H
 
+#include <asm/io.h>
 #include <asm/page.h>
 
 extern void setup_chip_clocksource(void);
@@ -22,13 +23,9 @@ read_rc_conf(unsigned long node, unsigned long rc,
 		unsigned int offset)
 {
 	void __iomem *addr;
-	unsigned int value;
 
 	addr = __va(MK_RC_CFG(node, rc) | offset);
-	value = *(volatile unsigned int *)addr;
-	mb();
-
-	return value;
+	return readl(addr);
 }
 
 static inline void
@@ -38,8 +35,7 @@ write_rc_conf(unsigned long node, unsigned long rc,
 	void __iomem *addr;
 
 	addr = __va(MK_RC_CFG(node, rc) | offset);
-	*(unsigned int *)addr = data;
-	mb();
+	writel(data, addr);
 }
 
 static inline  unsigned long
@@ -47,13 +43,9 @@ read_piu_ior0(unsigned long node, unsigned long rc,
 		unsigned int reg)
 {
 	void __iomem *addr;
-	unsigned long value;
 
 	addr = __va(MK_PIU_IOR0(node, rc) + reg);
-	value = *(volatile unsigned long __iomem *)addr;
-	mb();
-
-	return value;
+	return readq(addr);
 }
 
 static inline void
@@ -63,8 +55,7 @@ write_piu_ior0(unsigned long node, unsigned long rc,
 	void __iomem *addr;
 
 	addr = __va(MK_PIU_IOR0(node, rc) + reg);
-	*(unsigned long __iomem *)addr = data;
-	mb();
+	writeq(data, addr);
 }
 
 static inline  unsigned long
@@ -72,13 +63,9 @@ read_piu_ior1(unsigned long node, unsigned long rc,
 		unsigned int reg)
 {
 	void __iomem *addr;
-	unsigned long value;
 
 	addr = __va(MK_PIU_IOR1(node, rc) + reg);
-	value = *(volatile unsigned long __iomem *)addr;
-	mb();
-
-	return value;
+	return readq(addr);
 }
 
 static inline void
@@ -88,21 +75,16 @@ write_piu_ior1(unsigned long node, unsigned long rc,
 	void __iomem *addr;
 
 	addr = __va(MK_PIU_IOR1(node, rc) + reg);
-	*(volatile unsigned long __iomem *)addr = data;
-	mb();
+	writeq(data, addr);
 }
 
 static inline unsigned long
 sw64_io_read(unsigned long node, unsigned long reg)
 {
 	void __iomem *addr;
-	unsigned long value;
 
 	addr = __va(SW64_IO_BASE(node) | reg);
-	value = *(volatile unsigned long __iomem *)addr;
-	mb();
-
-	return value;
+	return readq(addr);
 }
 
 static inline void
@@ -111,7 +93,6 @@ sw64_io_write(unsigned long node, unsigned long reg, unsigned long data)
 	void __iomem *addr;
 
 	addr = __va(SW64_IO_BASE(node) | reg);
-	*(volatile unsigned long __iomem *)addr = data;
-	mb();
+	writeq(data, addr);
 }
 #endif
-- 
2.33.0

