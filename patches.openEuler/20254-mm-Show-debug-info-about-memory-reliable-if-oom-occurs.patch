From bfdc680cdca351baa803766c2a93ac74c9e76f64 Mon Sep 17 00:00:00 2001
From: Ma Wupeng <mawupeng1@huawei.com>
Date: Fri, 11 Nov 2022 09:32:40 +0800
Subject: [PATCH] mm: Show debug info about memory reliable if oom occurs
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: bfdc680cdca351baa803766c2a93ac74c9e76f64
Modified-by-SEL: No


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I4SK3S
CVE: NA

--------------------------------

Show debug info about memory reliable if oom occurs.

Signed-off-by: Ma Wupeng <mawupeng1@huawei.com>
Reviewed-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 include/linux/mem_reliable.h |  2 ++
 lib/show_mem.c               |  1 +
 mm/mem_reliable.c            | 38 ++++++++++++++++++++++++++++++++++++
 3 files changed, 41 insertions(+)

diff --git a/include/linux/mem_reliable.h b/include/linux/mem_reliable.h
index a041098c2158..5e14980d5793 100644
--- a/include/linux/mem_reliable.h
+++ b/include/linux/mem_reliable.h
@@ -38,6 +38,7 @@ extern void reliable_lru_add_batch(int zid, enum lru_list lru,
 extern bool mem_reliable_counter_initialized(void);
 extern void mem_reliable_out_of_memory(gfp_t gfp_mask, unsigned int order,
 				       int preferred_nid, nodemask_t *nodemask);
+extern void reliable_show_mem_info(void);
 
 static inline bool mem_reliable_is_enabled(void)
 {
@@ -162,6 +163,7 @@ static inline void mem_reliable_out_of_memory(gfp_t gfp_mask,
 					      int preferred_nid,
 					      nodemask_t *nodemask) {}
 static inline bool reliable_allow_fb_enabled(void) { return false; }
+static inline void reliable_show_mem_info(void) {}
 #endif
 
 #endif
diff --git a/lib/show_mem.c b/lib/show_mem.c
index 1c26c14ffbb9..11751aebc98f 100644
--- a/lib/show_mem.c
+++ b/lib/show_mem.c
@@ -41,4 +41,5 @@ void show_mem(unsigned int filter, nodemask_t *nodemask)
 #ifdef CONFIG_MEMORY_FAILURE
 	printk("%lu pages hwpoisoned\n", atomic_long_read(&num_poisoned_pages));
 #endif
+	reliable_show_mem_info();
 }
diff --git a/mm/mem_reliable.c b/mm/mem_reliable.c
index f3738f37d802..125f6ef5587b 100644
--- a/mm/mem_reliable.c
+++ b/mm/mem_reliable.c
@@ -431,6 +431,44 @@ static void mem_reliable_feature_disable(int idx)
 	pr_info("%s is disabled\n", str);
 }
 
+void reliable_show_mem_info(void)
+{
+	if (!mem_reliable_is_enabled())
+		return;
+
+	pr_info("ReliableTotal: %lu kB\n", total_reliable_pages()
+						   << (PAGE_SHIFT - 10));
+	pr_info("ReliableUsed: %lu kB\n", used_reliable_pages()
+						  << (PAGE_SHIFT - 10));
+	pr_info("ReliableTaskLimit: %lu kB\n", task_reliable_limit >> 10);
+	pr_info("ReliableTaskUsed: %lld kB\n", task_reliable_used_pages()
+						       << (PAGE_SHIFT - 10));
+
+	if (shmem_reliable_is_enabled()) {
+		pr_info("ReliableShmemPagesLimit: %ld\n",
+			shmem_reliable_nr_page);
+		pr_info("ReliableShmem: %llu kB\n",
+			percpu_counter_sum(&reliable_shmem_used_nr_page)
+				<< (PAGE_SHIFT - 10));
+	}
+
+	if (pagecache_reliable_is_enabled()) {
+		s64 nr_pagecache_pages = 0;
+		unsigned long num = 0;
+
+		num += global_node_page_state(NR_LRU_BASE + LRU_ACTIVE_FILE);
+		num += global_node_page_state(NR_LRU_BASE + LRU_INACTIVE_FILE);
+		pr_info("ReliableFileCacheLimit: %lu kB\n",
+			reliable_pagecache_max_bytes >> 10);
+		pr_info("FileCache: %lu kB\n", num << (PAGE_SHIFT - 10));
+
+		nr_pagecache_pages =
+			percpu_counter_sum_positive(&pagecache_reliable_pages);
+		pr_info("ReliableFileCache: %llu kB\n",
+			nr_pagecache_pages << (PAGE_SHIFT - 10));
+	}
+}
+
 void mem_reliable_out_of_memory(gfp_t gfp, unsigned int order,
 				int preferred_nid, nodemask_t *nodemask)
 {
-- 
2.33.0

