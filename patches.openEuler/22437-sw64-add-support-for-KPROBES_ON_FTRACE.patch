From 0bf6e0a20279d827ff772af60ae6c79a43effe1d Mon Sep 17 00:00:00 2001
From: Gu Zitao <guzitao@wxiat.com>
Date: Wed, 16 Nov 2022 09:03:48 +0800
Subject: [PATCH] sw64: add support for KPROBES_ON_FTRACE
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 0bf6e0a20279d827ff772af60ae6c79a43effe1d
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I645TO

--------------------------------

This patch adds support for KPROBES_ON_FTRACE on SW64, and it allows
kprobes to be placed on ftrace _mcount() call sites.

However, kprobe_ftrace_handler() makes ftrace_regs_caller() return
to the instruction after _mcount() call site. Then if the function
accesses global symbol with an address caculated based on gp($29),
it'll access a wrong address because gp has been changed in
ftrace_regs_caller().

To fix it, gp has to be saved and restored in ftrace_regs_caller().

With this patch, ftrace/kprobe selftests return passed.

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Reviewed-by: He Sheng <hesheng@wxiat.com>
Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/Kconfig                         |  1 +
 arch/sw_64/include/asm/kprobes.h           |  5 +++
 arch/sw_64/kernel/entry-ftrace.S           |  2 +
 arch/sw_64/kernel/kprobes/Makefile         |  2 +-
 arch/sw_64/kernel/kprobes/kprobes-ftrace.c | 48 ++++++++++++++++++++++
 5 files changed, 57 insertions(+), 1 deletion(-)
 create mode 100644 arch/sw_64/kernel/kprobes/kprobes-ftrace.c

diff --git a/arch/sw_64/Kconfig b/arch/sw_64/Kconfig
index 47a191e27aab..832e7a7a02e0 100644
--- a/arch/sw_64/Kconfig
+++ b/arch/sw_64/Kconfig
@@ -82,6 +82,7 @@ config SW64
 	select HAVE_FUNCTION_TRACER
 	select HAVE_IDE
 	select HAVE_KPROBES
+	select HAVE_KPROBES_ON_FTRACE
 	select HAVE_KRETPROBES
 	select HAVE_LIVEPATCH if HAVE_DYNAMIC_FTRACE_WITH_REGS
 	select HAVE_MEMBLOCK
diff --git a/arch/sw_64/include/asm/kprobes.h b/arch/sw_64/include/asm/kprobes.h
index 6b7e4548a8bd..0c7be8109ed2 100644
--- a/arch/sw_64/include/asm/kprobes.h
+++ b/arch/sw_64/include/asm/kprobes.h
@@ -45,6 +45,11 @@ void arch_remove_kprobe(struct kprobe *p);
 struct arch_specific_insn {
 	/* copy of the original instruction */
 	kprobe_opcode_t *insn;
+	/*
+	 * Set in kprobes code, initially to 0. If the instruction can be
+	 * eumulated, this is set to 1, if not, to -1.
+	 */
+	int boostable;
 };
 
 struct prev_kprobe {
diff --git a/arch/sw_64/kernel/entry-ftrace.S b/arch/sw_64/kernel/entry-ftrace.S
index 26bcc71b9db1..53125495f4e5 100644
--- a/arch/sw_64/kernel/entry-ftrace.S
+++ b/arch/sw_64/kernel/entry-ftrace.S
@@ -89,6 +89,7 @@
 	stl	$26, PT_REGS_R26($sp)
 	stl	$27, PT_REGS_R27($sp)
 	stl	$28, PT_REGS_R28($sp)
+	stl	$29, PT_REGS_GP($sp)
 	.endm
 
 	.macro RESTORE_PT_REGS
@@ -121,6 +122,7 @@
 	ldl	$26, PT_REGS_R26($sp)
 	ldl	$27, PT_REGS_R27($sp)
 	ldl	$28, PT_REGS_R28($sp)
+	ldl	$29, PT_REGS_GP($sp)
 	ldi	$sp, PT_REGS_SIZE($sp)
 	.endm
 
diff --git a/arch/sw_64/kernel/kprobes/Makefile b/arch/sw_64/kernel/kprobes/Makefile
index b3b1d849a63a..110ba2bf7752 100644
--- a/arch/sw_64/kernel/kprobes/Makefile
+++ b/arch/sw_64/kernel/kprobes/Makefile
@@ -1,3 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_KPROBES)           += kprobes.o decode-insn.o
-obj-$(CONFIG_KPROBES_ON_FTRACE) += ftrace.o
+obj-$(CONFIG_KPROBES_ON_FTRACE) += kprobes-ftrace.o
diff --git a/arch/sw_64/kernel/kprobes/kprobes-ftrace.c b/arch/sw_64/kernel/kprobes/kprobes-ftrace.c
new file mode 100644
index 000000000000..69fd38135cad
--- /dev/null
+++ b/arch/sw_64/kernel/kprobes/kprobes-ftrace.c
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Dynamic Ftrace based Kprobes Optimization
+ */
+
+#include <linux/kprobes.h>
+#include <linux/ptrace.h>
+#include <linux/hardirq.h>
+#include <linux/preempt.h>
+#include <linux/ftrace.h>
+
+/* Ftrace callback handler for kprobes */
+void kprobe_ftrace_handler(unsigned long ip, unsigned long parent_ip,
+			   struct ftrace_ops *ops, struct pt_regs *regs)
+{
+	struct kprobe *p;
+	struct kprobe_ctlblk *kcb;
+
+	p = get_kprobe((kprobe_opcode_t *)ip);
+	if (unlikely(!p) || kprobe_disabled(p))
+		return;
+
+	kcb = get_kprobe_ctlblk();
+	if (kprobe_running()) {
+		kprobes_inc_nmissed_count(p);
+	} else {
+		regs->r28 -= MCOUNT_INSN_SIZE;
+
+		__this_cpu_write(current_kprobe, p);
+		kcb->kprobe_status = KPROBE_HIT_ACTIVE;
+		if (!p->pre_handler || !p->pre_handler(p, regs)) {
+			regs->r28 += MCOUNT_INSN_SIZE;
+			if (unlikely(p->post_handler)) {
+				kcb->kprobe_status = KPROBE_HIT_SSDONE;
+				p->post_handler(p, regs, 0);
+			}
+		}
+		__this_cpu_write(current_kprobe, NULL);
+	}
+}
+NOKPROBE_SYMBOL(kprobe_ftrace_handler);
+
+int arch_prepare_kprobe_ftrace(struct kprobe *p)
+{
+	p->ainsn.insn = NULL;
+	p->ainsn.boostable = -1;
+	return 0;
+}
-- 
2.33.0

