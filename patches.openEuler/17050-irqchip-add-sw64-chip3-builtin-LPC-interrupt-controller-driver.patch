From d351c1bdf7563b31109bf0a01feb015233a01f2d Mon Sep 17 00:00:00 2001
From: Zhu Donghong <zhudonghong@wxiat.com>
Date: Wed, 18 May 2022 15:23:55 +0800
Subject: [PATCH] irqchip: add sw64 chip3 builtin LPC interrupt controller
 driver
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: d351c1bdf7563b31109bf0a01feb015233a01f2d
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5G7AK

--------------------------------

This adds an irqchip driver for the secondary interrupt controllers
based on sw64 chip3 cpu builtin LPC.

Signed-off-by: Zhu Donghong <zhudonghong@wxiat.com>

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 drivers/irqchip/Kconfig        |   7 ++
 drivers/irqchip/Makefile       |   1 +
 drivers/irqchip/irq-lpc.c      | 137 +++++++++++++++++++++++++++++++++
 drivers/mfd/lpc_sunway_chip3.c | 130 -------------------------------
 4 files changed, 145 insertions(+), 130 deletions(-)
 create mode 100644 drivers/irqchip/irq-lpc.c

diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 375ba3b30b72..5bf6cf60999b 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -9,6 +9,13 @@ config SW64_INTC
            The INTC controls devices interrupts and connects them to each
            core's local interrupt controller.
 
+config SW64_CHIP3_LPC
+	bool "SW64 Chip3 Buildin LPC Interrupt Controller"
+	depends on SW64_CHIP3
+	help
+           This enables support for the LPC interrupt controller bultin in
+	   on chip3 series.
+
 config IRQCHIP
 	def_bool y
 	depends on OF_IRQ
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 4c78b0f64e6c..78eb12ab4d4c 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_ARCH_SUNXI)		+= irq-sunxi-nmi.o
 obj-$(CONFIG_ARCH_SPEAR3XX)		+= spear-shirq.o
 obj-$(CONFIG_ARM_GIC)			+= irq-gic.o irq-gic-common.o
 obj-$(CONFIG_SW64_INTC)			+= irq-intc-v1.o
+obj-$(CONFIG_SW64_CHIP3_LPC)		+= irq-lpc.o
 obj-$(CONFIG_ARM_GIC_PM)		+= irq-gic-pm.o
 obj-$(CONFIG_ARCH_REALVIEW)		+= irq-gic-realview.o
 obj-$(CONFIG_ARM_GIC_V2M)		+= irq-gic-v2m.o
diff --git a/drivers/irqchip/irq-lpc.c b/drivers/irqchip/irq-lpc.c
new file mode 100644
index 000000000000..1cbf87478242
--- /dev/null
+++ b/drivers/irqchip/irq-lpc.c
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/bitops.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/interrupt.h>
+
+#define LPC_NR_IRQS 16
+#define	LPC_IRQ  0x4
+#define	LPC_IRQ_MASK  0x8
+
+struct lpc_intc_data {
+	struct irq_domain *domain;
+	struct irq_chip_generic *gc;
+};
+
+static void lpc_irq_mask_ack(struct irq_data *data)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);
+	struct irq_chip_type *ct = irq_data_get_chip_type(data);
+	unsigned int mask = data->mask;
+
+	irq_gc_lock(gc);
+	*ct->mask_cache |= mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_reg_writel(gc, mask, ct->regs.ack);
+	irq_gc_unlock(gc);
+}
+
+static void lpc_irq_handler(struct irq_desc *desc)
+{
+	struct lpc_intc_data *b = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned int irq;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+
+	status = irq_reg_readl(b->gc, LPC_IRQ);
+
+	if (status == 0) {
+		raw_spin_lock(&desc->lock);
+		handle_bad_irq(desc);
+		raw_spin_unlock(&desc->lock);
+		goto out;
+	}
+
+	while (status) {
+		irq = __ffs(status);
+		status &= ~BIT(irq);
+		generic_handle_irq(irq_find_mapping(b->domain, irq));
+	}
+
+out:
+	chained_irq_exit(chip, desc);
+}
+
+static int __init lpc_intc_of_init(struct device_node *np,
+				  struct device_node *parent)
+{
+	unsigned int set = IRQ_NOPROBE | IRQ_LEVEL;
+	struct lpc_intc_data *data;
+	struct irq_chip_type *ct;
+	int parent_irq, ret;
+	void __iomem *base;
+	int hwirq = 0;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_err("failed to remap lpc intc registers\n");
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	parent_irq = irq_of_parse_and_map(np, 0);
+	if (!parent_irq) {
+		pr_err("failed to find parent interrupt\n");
+		ret = -EINVAL;
+		goto out_unmap;
+	}
+
+	data->domain = irq_domain_add_linear(np, LPC_NR_IRQS,
+				&irq_generic_chip_ops, NULL);
+	if (!data->domain) {
+		ret = -ENOMEM;
+		goto out_unmap;
+	}
+
+	/* Allocate a single Generic IRQ chip for this node */
+	ret = irq_alloc_domain_generic_chips(data->domain, 16, 1, np->name,
+					     handle_level_irq, 0, set,
+					     IRQ_GC_INIT_MASK_CACHE);
+	if (ret) {
+		pr_err("failed to allocate generic irq chip\n");
+		goto out_free_domain;
+	}
+
+	/* Set the IRQ chaining logic */
+	irq_set_chained_handler_and_data(parent_irq,
+					 lpc_irq_handler, data);
+
+	data->gc = irq_get_domain_generic_chip(data->domain, 0);
+	data->gc->reg_base = base;
+	data->gc->private = data;
+
+	ct = data->gc->chip_types;
+
+	ct->regs.ack = LPC_IRQ;
+	ct->regs.mask = LPC_IRQ_MASK;
+	ct->chip.irq_mask = irq_gc_mask_set_bit;
+	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
+	ct->chip.irq_ack = irq_gc_ack_set_bit;
+	ct->chip.irq_mask_ack = lpc_irq_mask_ack;
+
+	for (hwirq = 0 ; hwirq < 16 ; hwirq++)
+		irq_create_mapping(data->domain, hwirq);
+
+	/* Enable LPC interrupts */
+	writel(0xffffebdd, base + LPC_IRQ_MASK);
+
+	return 0;
+
+out_free_domain:
+	irq_domain_remove(data->domain);
+out_unmap:
+	iounmap(base);
+out_free:
+	kfree(data);
+	return ret;
+}
+IRQCHIP_DECLARE(sw_lpc_intc, "sw64,lpc_intc", lpc_intc_of_init);
diff --git a/drivers/mfd/lpc_sunway_chip3.c b/drivers/mfd/lpc_sunway_chip3.c
index 793b557195c2..878aff87c992 100644
--- a/drivers/mfd/lpc_sunway_chip3.c
+++ b/drivers/mfd/lpc_sunway_chip3.c
@@ -75,53 +75,16 @@ enum {
 	LPC_DMA_SWRST = 0x70,
 };
 
-enum {
-	LPC_IRQ0 = 0,		/* 8254 Timer */
-	LPC_IRQ1,		/* Keyboard */
-	LPC_IRQ2,		/* Reserved */
-	LPC_IRQ3,		/* UART */
-	LPC_IRQ4,		/* UART */
-	LPC_IRQ5,		/* LPC Parallel Port2 */
-	LPC_IRQ6,		/* FDC-Floppy Disk Controller */
-	LPC_IRQ7,		/* LPT-Parallel Port1 */
-	LPC_NR_IRQS,
-	LPC_IRQ8,		/* RTC */
-	LPC_IRQ9,		/* Undefined */
-	LPC_IRQ10,		/* Undefined */
-	LPC_IRQ11,		/* Undefined */
-	LPC_IRQ12,		/* Mouse */
-	LPC_IRQ13,		/* Undefined */
-	LPC_IRQ14,		/* Undefined */
-	LPC_IRQ15,		/* Undefined */
-};
-
 struct lpc_chip3_adapter {
 	void __iomem *hst_regs;
 	struct device *dev;
 	int irq;
-	struct irq_chip_generic *gc;
 	unsigned int features;
 };
 
 static struct resource superio_chip3_resources[] = {
 	{
 		.flags = IORESOURCE_IO,
-	}, {
-		.start = LPC_IRQ1,
-		.flags = IORESOURCE_IRQ,
-		.name = "i8042_kbd_irq",
-	}, {
-		.start = LPC_IRQ12,
-		.flags = IORESOURCE_IRQ,
-		.name = "i8042_aux_irq",
-	}, {
-		.start = LPC_IRQ5,
-		.flags = IORESOURCE_IRQ,
-		.name = "uart0_irq",
-	}, {
-		.start = LPC_IRQ4,
-		.flags = IORESOURCE_IRQ,
-		.name = "uart1_irq",
 	}
 };
 
@@ -218,75 +181,9 @@ static void lpc_fw_flash_init(struct platform_device *pdev,
 
 }
 
-static u32 lpc_do_irq(struct lpc_chip3_adapter *lpc_adapter)
-{
-	u32 irq_status = readl_relaxed(lpc_adapter->hst_regs + LPC_IRQ);
-	u32 ret = irq_status;
-
-	DBG_LPC("%s irq_status=%#x\n", __func__, irq_status);
-	while (irq_status) {
-		int hwirq = fls(irq_status) - 1;
-
-		generic_handle_irq(hwirq);
-		irq_status &= ~BIT(hwirq);
-	}
-
-	lpc_writel(lpc_adapter->hst_regs, LPC_IRQ, ret);
-	return 1;
-}
-
-static void lpc_irq_handler_mfd(struct irq_desc *desc)
-{
-	unsigned int irq = irq_desc_get_irq(desc);
-	struct lpc_chip3_adapter *lpc_adapter = irq_get_handler_data(irq);
-	u32 worked = 0;
-
-	DBG_LPC("enter %s line:%d\n", __func__, __LINE__);
-
-	worked = lpc_do_irq(lpc_adapter);
-	if (worked == IRQ_HANDLED)
-		dev_dbg(lpc_adapter->dev, "LPC irq handled.\n");
-
-	DBG_LPC("leave %s line:%d\n", __func__, __LINE__);
-}
-
-static void lpc_unmask_interrupt_all(struct lpc_chip3_adapter *lpc_adapter)
-{
-	lpc_writel(lpc_adapter->hst_regs, LPC_IRQ_MASK, 0);
-}
-
-static void lpc_irq_mask_ack(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	u32 mask = d->mask;
-
-	irq_gc_lock(gc);
-	*ct->mask_cache |= mask;
-	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
-	irq_reg_writel(gc, mask, ct->regs.ack);
-	irq_gc_unlock(gc);
-}
-
-static void lpc_enable_irqs(struct lpc_chip3_adapter *lpc_adapter)
-{
-	int interrupt = 0;
-
-	lpc_unmask_interrupt_all(lpc_adapter);
-
-	interrupt = lpc_readl(lpc_adapter->hst_regs, LPC_IRQ);
-
-	lpc_writel(lpc_adapter->hst_regs, LPC_CTL, 0x1600);
-	interrupt = lpc_readl(lpc_adapter->hst_regs, LPC_IRQ);
-}
-
 static int lpc_chip3_probe(struct platform_device *pdev)
 {
 	int ret;
-	int num_ct = 1;
-	int irq_base;
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
 	struct lpc_chip3_adapter *lpc_adapter;
 	struct resource *mem;
 
@@ -312,32 +209,6 @@ static int lpc_chip3_probe(struct platform_device *pdev)
 	lpc_adapter->dev = &pdev->dev;
 	lpc_adapter->features = 0;
 
-	lpc_adapter->irq = platform_get_irq(pdev, 0);
-	if (lpc_adapter->irq < 0) {
-		dev_err(&pdev->dev, "no irq resource?\n");
-		return lpc_adapter->irq;	/* -ENXIO */
-	}
-
-	irq_base = LPC_IRQ0;
-	gc = irq_alloc_generic_chip("LPC_CHIP3", num_ct, irq_base,
-				    lpc_adapter->hst_regs, handle_level_irq);
-
-	ct = gc->chip_types;
-	ct->regs.mask = LPC_IRQ_MASK;
-	ct->regs.ack = LPC_IRQ;
-	ct->chip.irq_mask = irq_gc_mask_set_bit;
-	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
-	ct->chip.irq_ack = irq_gc_ack_set_bit;
-	ct->chip.irq_mask_ack = lpc_irq_mask_ack;
-	irq_setup_generic_chip(gc, IRQ_MSK(LPC_NR_IRQS), 0, 0,
-			       IRQ_NOPROBE | IRQ_LEVEL);
-
-	lpc_adapter->gc = gc;
-
-	irq_set_handler_data(lpc_adapter->irq, lpc_adapter);
-	irq_set_chained_handler(lpc_adapter->irq,
-				(irq_flow_handler_t) lpc_irq_handler_mfd);
-
 	lpc_enable(lpc_adapter);
 
 	lpc_mem_flash_init(pdev, lpc_adapter);
@@ -350,7 +221,6 @@ static int lpc_chip3_probe(struct platform_device *pdev)
 		goto out_dev;
 
 	dev_info(lpc_adapter->dev, "probe succeed !\n");
-	lpc_enable_irqs(lpc_adapter);
 
 	return ret;
 
-- 
2.33.0

