From 6a228a8e903fa4f6578ff6bd5f6c788ef740ef93 Mon Sep 17 00:00:00 2001
From: Tong Tiangen <tongtiangen@huawei.com>
Date: Fri, 18 Nov 2022 02:08:58 +0000
Subject: [PATCH] arm64: add machine check safe sysctl interface
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 6a228a8e903fa4f6578ff6bd5f6c788ef740ef93
Modified-by-SEL: No


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5GB28
CVE: NA

-------------------------------

Add /proc/sys/kernel/machine_check_safe_enable. Set 1(default value) to
enable machine check safe support. Set 0(default) to disable machine
check safe support.

Signed-off-by: Tong Tiangen <tongtiangen@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 Documentation/admin-guide/sysctl/kernel.rst | 21 +++++++++++++++++++++
 arch/arm64/include/asm/processor.h          |  2 ++
 arch/arm64/mm/fault.c                       |  5 +++++
 kernel/sysctl.c                             | 11 +++++++++++
 4 files changed, 39 insertions(+)

diff --git a/Documentation/admin-guide/sysctl/kernel.rst b/Documentation/admin-guide/sysctl/kernel.rst
index a4b1ebc2e70b..f0271bc4ff95 100644
--- a/Documentation/admin-guide/sysctl/kernel.rst
+++ b/Documentation/admin-guide/sysctl/kernel.rst
@@ -478,6 +478,27 @@ if leaking kernel pointer values to unprivileged users is a concern.
 When ``kptr_restrict`` is set to 2, kernel pointers printed using
 %pK will be replaced with 0s regardless of privileges.
 
+machine_check_safe (arm64 only)
+================================
+
+Controls the kernel's behaviour when an hardware memory error is
+encountered in the following scenarios:
+
+=  ===================
+1  cow
+2  copy_mc_to_kernel
+3  copy_from_user
+4  copy_to_user
+5  get_user
+6  put_user
+=  ===================
+
+Correspondence between sysctl value and behavior:
+
+= =======================
+0 Kernel panic
+1 Kill related processes
+= =======================
 
 modprobe
 ========
diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
index 7172dab3b469..f1cfb52ba63c 100644
--- a/arch/arm64/include/asm/processor.h
+++ b/arch/arm64/include/asm/processor.h
@@ -88,6 +88,8 @@
 #define STACK_TOP		STACK_TOP_MAX
 #endif /* CONFIG_COMPAT */
 
+extern int sysctl_machine_check_safe;
+
 #ifndef CONFIG_ARM64_FORCE_52BIT
 #define arch_get_mmap_end(addr) ((addr > DEFAULT_MAP_WINDOW) ? TASK_SIZE :\
 				DEFAULT_MAP_WINDOW)
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index 4ab0ba661657..53cdcbda7cb6 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -40,6 +40,8 @@
 #include <asm/tlbflush.h>
 #include <asm/traps.h>
 
+int sysctl_machine_check_safe = 1;
+
 struct fault_info {
 	int	(*fn)(unsigned long addr, unsigned int esr,
 		      struct pt_regs *regs);
@@ -640,6 +642,9 @@ static bool arm64_do_kernel_sea(void __user *addr, unsigned int esr,
 	if (!IS_ENABLED(CONFIG_ARCH_HAS_COPY_MC))
 		return false;
 
+	if (!sysctl_machine_check_safe)
+		return false;
+
 	if (user_mode(regs))
 		return false;
 
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 3a9233b5a876..eb8db15b5902 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -3453,6 +3453,17 @@ static struct ctl_table debug_table[] = {
 		.extra1		= SYSCTL_ZERO,
 		.extra2		= SYSCTL_ONE,
 	},
+#endif
+#if defined(CONFIG_ARM64) && defined(CONFIG_ARCH_HAS_COPY_MC)
+	{
+		.procname       = "machine_check_safe",
+		.data           = &sysctl_machine_check_safe,
+		.maxlen         = sizeof(sysctl_machine_check_safe),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec_minmax,
+		.extra1         = SYSCTL_ZERO,
+		.extra2         = SYSCTL_ONE,
+	},
 #endif
 	{ }
 };
-- 
2.33.0

