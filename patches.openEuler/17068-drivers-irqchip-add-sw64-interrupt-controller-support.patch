From de13548b9a24e73d988b43fbad57f32cfb4adfd1 Mon Sep 17 00:00:00 2001
From: Zhu Donghong <zhudonghong@wxiat.com>
Date: Wed, 8 Jun 2022 09:49:30 +0800
Subject: [PATCH] drivers/irqchip: add sw64 interrupt controller support
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: de13548b9a24e73d988b43fbad57f32cfb4adfd1
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5GDHC

--------------------------------

Add a driver for the SW64 implementation of the CPU interrupt
controller(INTC). In fact, the INTC is just a software simulated
module to connect global interrupt sources to the local interrupt
controller on each core.

In addition, we rename irq-lpc.c and SW64_CHIP3_LPC config.

Signed-off-by: Zhu Donghong <zhudonghong@wxiat.com>

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/Kconfig                  |   8 +-
 arch/sw_64/chip/chip3/Makefile      |   1 -
 arch/sw_64/chip/chip3/irq_chip.c    |  85 ----------------
 drivers/irqchip/Kconfig             |  33 ++++---
 drivers/irqchip/Makefile            |   4 +-
 drivers/irqchip/irq-intc-v1.c       | 104 --------------------
 drivers/irqchip/irq-lpc.c           | 137 --------------------------
 drivers/irqchip/irq-sw64-intc-v2.c  | 145 ++++++++++++++++++++++++++++
 drivers/irqchip/irq-sw64-lpc-intc.c | 137 ++++++++++++++++++++++++++
 9 files changed, 304 insertions(+), 350 deletions(-)
 delete mode 100644 arch/sw_64/chip/chip3/irq_chip.c
 delete mode 100644 drivers/irqchip/irq-intc-v1.c
 delete mode 100644 drivers/irqchip/irq-lpc.c
 create mode 100644 drivers/irqchip/irq-sw64-intc-v2.c
 create mode 100644 drivers/irqchip/irq-sw64-lpc-intc.c

diff --git a/arch/sw_64/Kconfig b/arch/sw_64/Kconfig
index 0e32fc7e1f9a..ec6e583a5d9a 100644
--- a/arch/sw_64/Kconfig
+++ b/arch/sw_64/Kconfig
@@ -234,6 +234,7 @@ config PLATFORM_XUELANG
 	depends on SW64_CHIP3
 	select SPARSE_IRQ
 	select SYS_HAS_EARLY_PRINTK
+	select SW64_INTC_V2
 	help
 	  Sunway chip3 board chipset
 
@@ -736,15 +737,10 @@ endmenu
 
 menu "Boot options"
 
-config SW64_IRQ_CHIP
-	bool
-
 config USE_OF
 	bool "Flattened Device Tree support"
-	select GENERIC_IRQ_CHIP
-	select IRQ_DOMAIN
-	select SW64_IRQ_CHIP
 	select OF
+	select IRQ_DOMAIN
 	help
 	  Include support for flattened device tree machine descriptions.
 
diff --git a/arch/sw_64/chip/chip3/Makefile b/arch/sw_64/chip/chip3/Makefile
index 2b7b5790003f..ba0ab3f67f98 100644
--- a/arch/sw_64/chip/chip3/Makefile
+++ b/arch/sw_64/chip/chip3/Makefile
@@ -4,5 +4,4 @@ obj-y	:= chip.o i2c-lib.o
 
 obj-$(CONFIG_PCI)	+= pci-quirks.o
 obj-$(CONFIG_PCI_MSI)	+= msi.o vt_msi.o
-obj-$(CONFIG_SW64_IRQ_CHIP)	+= irq_chip.o
 obj-$(CONFIG_CPUFREQ_DEBUGFS)   += cpufreq_debugfs.o
diff --git a/arch/sw_64/chip/chip3/irq_chip.c b/arch/sw_64/chip/chip3/irq_chip.c
deleted file mode 100644
index 24dfa1e1a898..000000000000
--- a/arch/sw_64/chip/chip3/irq_chip.c
+++ /dev/null
@@ -1,85 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/irqdomain.h>
-#include <linux/irqchip.h>
-
-#include <asm/irq_impl.h>
-
-static void fake_irq_mask(struct irq_data *data)
-{
-}
-
-static void fake_irq_unmask(struct irq_data *data)
-{
-}
-
-static struct irq_chip onchip_intc = {
-	.name           = "SW fake Intc",
-	.irq_mask       = fake_irq_mask,
-	.irq_unmask     = fake_irq_unmask,
-};
-
-static int sw64_intc_domain_map(struct irq_domain *d, unsigned int irq,
-			      irq_hw_number_t hw)
-{
-
-	irq_set_chip_and_handler(irq, &onchip_intc, handle_level_irq);
-	irq_set_status_flags(irq, IRQ_LEVEL);
-	return 0;
-}
-
-static const struct irq_domain_ops sw64_intc_domain_ops = {
-	.xlate = irq_domain_xlate_onecell,
-	.map = sw64_intc_domain_map,
-};
-
-static struct irq_domain *root_domain;
-
-static int __init
-init_onchip_IRQ(struct device_node *intc, struct device_node *parent)
-{
-
-	int node = 0;
-	int hwirq = 0, nirq = 8;
-
-	if (parent)
-		panic("DeviceTree incore intc not a root irq controller\n");
-
-	root_domain = irq_domain_add_linear(intc, 8,
-						&sw64_intc_domain_ops, NULL);
-
-	if (!root_domain)
-		panic("root irq domain not avail\n");
-
-	/* with this we don't need to export root_domain */
-	irq_set_default_host(root_domain);
-
-	for (hwirq = 0 ; hwirq < nirq ; hwirq++)
-		irq_create_mapping(root_domain, hwirq);
-
-	/*enable MCU_DVC_INT_EN*/
-	sw64_io_write(node, MCU_DVC_INT_EN, 0xff);
-
-	return 0;
-}
-
-IRQCHIP_DECLARE(sw64_intc, "sw64,sw6_irq_controller", init_onchip_IRQ);
-
-static int __init
-init_onchip_vt_IRQ(struct device_node *intc, struct device_node *parent)
-{
-	if (parent)
-		panic("DeviceTree incore intc not a root irq controller\n");
-
-	root_domain = irq_domain_add_legacy(intc, 16, 0, 0,
-						&sw64_intc_domain_ops, NULL);
-
-	if (!root_domain)
-		panic("root irq domain not avail\n");
-
-	/* with this we don't need to export root_domain */
-	irq_set_default_host(root_domain);
-
-	return 0;
-}
-
-IRQCHIP_DECLARE(sw64_vt_intc, "sw64,sw6_irq_vt_controller", init_onchip_vt_IRQ);
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 5bf6cf60999b..dd35895c92f3 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -1,21 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 menu "IRQ chip support"
 
-config SW64_INTC
-	bool "SW64 Platform-Level Interrupt Controller"
-	depends on ACPI && SW64
-	help
-           This enables support for the INTC chip found in SW systems.
-           The INTC controls devices interrupts and connects them to each
-           core's local interrupt controller.
-
-config SW64_CHIP3_LPC
-	bool "SW64 Chip3 Buildin LPC Interrupt Controller"
-	depends on SW64_CHIP3
-	help
-           This enables support for the LPC interrupt controller bultin in
-	   on chip3 series.
-
 config IRQCHIP
 	def_bool y
 	depends on OF_IRQ
@@ -26,6 +11,24 @@ config ARM_GIC
 	select GENERIC_IRQ_MULTI_HANDLER
 	select GENERIC_IRQ_EFFECTIVE_AFF_MASK
 
+config SW64_INTC_V2
+	bool "SW64 Interrupt Controller V2"
+	depends on SW64_CHIP3
+	default y
+	select GENERIC_IRQ_CHIP
+	select IRQ_DOMAIN
+	help
+           This enables support for the INTC chip found in SW CHIP3 systems.
+           The INTC controls devices interrupts and connects them to each
+           core's local interrupt controller.
+
+config SW64_LPC_INTC
+	bool "SW64 cpu builtin LPC Interrupt Controller"
+	depends on SW64_INTC_V2
+	help
+	   Say yes here to add support for the SW64 cpu builtin LPC
+	   IRQ controller.
+
 config ARM_GIC_PM
 	bool
 	depends on PM
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 78eb12ab4d4c..14a022c074ce 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -27,8 +27,8 @@ obj-$(CONFIG_ARCH_SUNXI)		+= irq-sun4i.o
 obj-$(CONFIG_ARCH_SUNXI)		+= irq-sunxi-nmi.o
 obj-$(CONFIG_ARCH_SPEAR3XX)		+= spear-shirq.o
 obj-$(CONFIG_ARM_GIC)			+= irq-gic.o irq-gic-common.o
-obj-$(CONFIG_SW64_INTC)			+= irq-intc-v1.o
-obj-$(CONFIG_SW64_CHIP3_LPC)		+= irq-lpc.o
+obj-$(CONFIG_SW64_INTC_V2)     		+= irq-sw64-intc-v2.o
+obj-$(CONFIG_SW64_LPC_INTC)		+= irq-sw64-lpc-intc.o
 obj-$(CONFIG_ARM_GIC_PM)		+= irq-gic-pm.o
 obj-$(CONFIG_ARCH_REALVIEW)		+= irq-gic-realview.o
 obj-$(CONFIG_ARM_GIC_V2M)		+= irq-gic-v2m.o
diff --git a/drivers/irqchip/irq-intc-v1.c b/drivers/irqchip/irq-intc-v1.c
deleted file mode 100644
index 4519e96526fb..000000000000
--- a/drivers/irqchip/irq-intc-v1.c
+++ /dev/null
@@ -1,104 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include <linux/acpi_iort.h>
-#include <linux/msi.h>
-#include <linux/acpi.h>
-#include <linux/irqdomain.h>
-#include <linux/interrupt.h>
-#include <linux/cpumask.h>
-#include <linux/io.h>
-#include <linux/percpu.h>
-#include <linux/slab.h>
-#include <linux/irqchip.h>
-#include <asm/sw64io.h>
-static void fake_irq_mask(struct irq_data *data)
-{
-}
-
-static void fake_irq_unmask(struct irq_data *data)
-{
-}
-
-static struct irq_chip onchip_intc = {
-	.name           = "SW fake Intc",
-	.irq_mask       = fake_irq_mask,
-	.irq_unmask     = fake_irq_unmask,
-};
-
-static int sw_intc_domain_map(struct irq_domain *d, unsigned int irq,
-				irq_hw_number_t hw)
-{
-	irq_set_chip_and_handler(irq, &onchip_intc, handle_level_irq);
-	irq_set_status_flags(irq, IRQ_LEVEL);
-	return 0;
-}
-
-static const struct irq_domain_ops intc_irq_domain_ops = {
-	.xlate = irq_domain_xlate_onecell,
-	.map = sw_intc_domain_map,
-};
-
-#ifdef CONFIG_ACPI
-
-static int __init
-intc_parse_madt(union acpi_subtable_headers *header,
-		       const unsigned long end)
-{
-	struct acpi_madt_io_sapic *its_entry;
-	static struct irq_domain *root_domain;
-	int intc_irqs = 8, irq_base = NR_IRQS_LEGACY;
-	irq_hw_number_t hwirq_base = 0;
-	int irq_start = -1;
-
-	its_entry = (struct acpi_madt_io_sapic *)header;
-
-	intc_irqs -= hwirq_base; /* calculate # of irqs to allocate */
-
-	irq_base = irq_alloc_descs(irq_start, 16, intc_irqs,
-			numa_node_id());
-	if (irq_base < 0) {
-		WARN(1, "Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",
-				irq_start);
-		irq_base = irq_start;
-	}
-
-	root_domain = irq_domain_add_legacy(NULL, intc_irqs, irq_base,
-			hwirq_base, &intc_irq_domain_ops, NULL);
-
-	if (!root_domain)
-		pr_err("Failed to create irqdomain");
-
-	irq_set_default_host(root_domain);
-
-	sw64_io_write(0, MCU_DVC_INT_EN, 0xff);
-
-	return 0;
-}
-
-static int __init acpi_intc_init(void)
-{
-	int count = 0;
-
-	count = acpi_table_parse_madt(ACPI_MADT_TYPE_IO_SAPIC,
-			      intc_parse_madt, 0);
-
-	if (count <= 0) {
-		pr_err("No valid intc entries exist\n");
-		return -EINVAL;
-	}
-	return 0;
-}
-#else
-static int __init acpi_intc_init(void)
-{
-	return 0;
-}
-#endif
-
-static int __init intc_init(void)
-{
-	acpi_intc_init();
-
-	return 0;
-}
-subsys_initcall(intc_init);
diff --git a/drivers/irqchip/irq-lpc.c b/drivers/irqchip/irq-lpc.c
deleted file mode 100644
index 1cbf87478242..000000000000
--- a/drivers/irqchip/irq-lpc.c
+++ /dev/null
@@ -1,137 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/bitops.h>
-#include <linux/irq.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/irqchip.h>
-#include <linux/irqchip/chained_irq.h>
-#include <linux/interrupt.h>
-
-#define LPC_NR_IRQS 16
-#define	LPC_IRQ  0x4
-#define	LPC_IRQ_MASK  0x8
-
-struct lpc_intc_data {
-	struct irq_domain *domain;
-	struct irq_chip_generic *gc;
-};
-
-static void lpc_irq_mask_ack(struct irq_data *data)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);
-	struct irq_chip_type *ct = irq_data_get_chip_type(data);
-	unsigned int mask = data->mask;
-
-	irq_gc_lock(gc);
-	*ct->mask_cache |= mask;
-	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
-	irq_reg_writel(gc, mask, ct->regs.ack);
-	irq_gc_unlock(gc);
-}
-
-static void lpc_irq_handler(struct irq_desc *desc)
-{
-	struct lpc_intc_data *b = irq_desc_get_handler_data(desc);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	unsigned int irq;
-	u32 status;
-
-	chained_irq_enter(chip, desc);
-
-	status = irq_reg_readl(b->gc, LPC_IRQ);
-
-	if (status == 0) {
-		raw_spin_lock(&desc->lock);
-		handle_bad_irq(desc);
-		raw_spin_unlock(&desc->lock);
-		goto out;
-	}
-
-	while (status) {
-		irq = __ffs(status);
-		status &= ~BIT(irq);
-		generic_handle_irq(irq_find_mapping(b->domain, irq));
-	}
-
-out:
-	chained_irq_exit(chip, desc);
-}
-
-static int __init lpc_intc_of_init(struct device_node *np,
-				  struct device_node *parent)
-{
-	unsigned int set = IRQ_NOPROBE | IRQ_LEVEL;
-	struct lpc_intc_data *data;
-	struct irq_chip_type *ct;
-	int parent_irq, ret;
-	void __iomem *base;
-	int hwirq = 0;
-
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
-
-	base = of_iomap(np, 0);
-	if (!base) {
-		pr_err("failed to remap lpc intc registers\n");
-		ret = -ENOMEM;
-		goto out_free;
-	}
-
-	parent_irq = irq_of_parse_and_map(np, 0);
-	if (!parent_irq) {
-		pr_err("failed to find parent interrupt\n");
-		ret = -EINVAL;
-		goto out_unmap;
-	}
-
-	data->domain = irq_domain_add_linear(np, LPC_NR_IRQS,
-				&irq_generic_chip_ops, NULL);
-	if (!data->domain) {
-		ret = -ENOMEM;
-		goto out_unmap;
-	}
-
-	/* Allocate a single Generic IRQ chip for this node */
-	ret = irq_alloc_domain_generic_chips(data->domain, 16, 1, np->name,
-					     handle_level_irq, 0, set,
-					     IRQ_GC_INIT_MASK_CACHE);
-	if (ret) {
-		pr_err("failed to allocate generic irq chip\n");
-		goto out_free_domain;
-	}
-
-	/* Set the IRQ chaining logic */
-	irq_set_chained_handler_and_data(parent_irq,
-					 lpc_irq_handler, data);
-
-	data->gc = irq_get_domain_generic_chip(data->domain, 0);
-	data->gc->reg_base = base;
-	data->gc->private = data;
-
-	ct = data->gc->chip_types;
-
-	ct->regs.ack = LPC_IRQ;
-	ct->regs.mask = LPC_IRQ_MASK;
-	ct->chip.irq_mask = irq_gc_mask_set_bit;
-	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
-	ct->chip.irq_ack = irq_gc_ack_set_bit;
-	ct->chip.irq_mask_ack = lpc_irq_mask_ack;
-
-	for (hwirq = 0 ; hwirq < 16 ; hwirq++)
-		irq_create_mapping(data->domain, hwirq);
-
-	/* Enable LPC interrupts */
-	writel(0xffffebdd, base + LPC_IRQ_MASK);
-
-	return 0;
-
-out_free_domain:
-	irq_domain_remove(data->domain);
-out_unmap:
-	iounmap(base);
-out_free:
-	kfree(data);
-	return ret;
-}
-IRQCHIP_DECLARE(sw_lpc_intc, "sw64,lpc_intc", lpc_intc_of_init);
diff --git a/drivers/irqchip/irq-sw64-intc-v2.c b/drivers/irqchip/irq-sw64-intc-v2.c
new file mode 100644
index 000000000000..8640c4aa9506
--- /dev/null
+++ b/drivers/irqchip/irq-sw64-intc-v2.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/irqdomain.h>
+#include <linux/irqchip.h>
+#include <linux/acpi.h>
+#include <linux/acpi_iort.h>
+#include <linux/of_irq.h>
+#include <asm/sw64io.h>
+
+static void fake_irq_mask(struct irq_data *data)
+{
+}
+
+static void fake_irq_unmask(struct irq_data *data)
+{
+}
+
+static struct irq_chip onchip_intc = {
+	.name           = "SW fake Intc",
+	.irq_mask       = fake_irq_mask,
+	.irq_unmask     = fake_irq_unmask,
+};
+
+static int sw64_intc_domain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hw)
+{
+
+	irq_set_chip_and_handler(irq, &onchip_intc, handle_level_irq);
+	irq_set_status_flags(irq, IRQ_LEVEL);
+	return 0;
+}
+
+static const struct irq_domain_ops sw64_intc_domain_ops = {
+	.xlate = irq_domain_xlate_onecell,
+	.map = sw64_intc_domain_map,
+};
+
+static int __init
+intc_parse_madt(union acpi_subtable_headers *header,
+		       const unsigned long end)
+{
+	struct acpi_madt_io_sapic *its_entry;
+	static struct irq_domain *root_domain;
+	int intc_irqs = 8, irq_base = NR_IRQS_LEGACY;
+	irq_hw_number_t hwirq_base = 0;
+	int irq_start = -1;
+
+	its_entry = (struct acpi_madt_io_sapic *)header;
+
+	intc_irqs -= hwirq_base; /* calculate # of irqs to allocate */
+
+	irq_base = irq_alloc_descs(irq_start, 16, intc_irqs,
+			numa_node_id());
+	if (irq_base < 0) {
+		WARN(1, "Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",
+				irq_start);
+		irq_base = irq_start;
+	}
+
+	root_domain = irq_domain_add_legacy(NULL, intc_irqs, irq_base,
+			hwirq_base, &sw64_intc_domain_ops, NULL);
+
+	if (!root_domain)
+		pr_err("Failed to create irqdomain");
+
+	irq_set_default_host(root_domain);
+
+	sw64_io_write(0, MCU_DVC_INT_EN, 0xff);
+
+	return 0;
+}
+
+static int __init acpi_intc_init(void)
+{
+	int count = 0;
+
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_IO_SAPIC,
+			      intc_parse_madt, 0);
+
+	if (count <= 0) {
+		pr_err("No valid intc entries exist\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int __init intc_init(void)
+{
+	acpi_intc_init();
+
+	return 0;
+}
+
+subsys_initcall(intc_init);
+
+static struct irq_domain *root_domain;
+
+static int __init
+init_onchip_IRQ(struct device_node *intc, struct device_node *parent)
+{
+
+	int node = 0;
+	int hwirq = 0, nirq = 8;
+
+	if (parent)
+		panic("DeviceTree incore intc not a root irq controller\n");
+
+	root_domain = irq_domain_add_linear(intc, 8,
+						&sw64_intc_domain_ops, NULL);
+
+	if (!root_domain)
+		panic("root irq domain not avail\n");
+
+	/* with this we don't need to export root_domain */
+	irq_set_default_host(root_domain);
+
+	for (hwirq = 0 ; hwirq < nirq ; hwirq++)
+		irq_create_mapping(root_domain, hwirq);
+
+	/*enable MCU_DVC_INT_EN*/
+	sw64_io_write(node, MCU_DVC_INT_EN, 0xff);
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(sw64_intc, "sw64,sw6_irq_controller", init_onchip_IRQ);
+
+static int __init
+init_onchip_vt_IRQ(struct device_node *intc, struct device_node *parent)
+{
+	if (parent)
+		panic("DeviceTree incore intc not a root irq controller\n");
+
+	root_domain = irq_domain_add_legacy(intc, 16, 0, 0,
+						&sw64_intc_domain_ops, NULL);
+
+	if (!root_domain)
+		panic("root irq domain not avail\n");
+
+	/* with this we don't need to export root_domain */
+	irq_set_default_host(root_domain);
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(sw64_vt_intc, "sw64,sw6_irq_vt_controller", init_onchip_vt_IRQ);
diff --git a/drivers/irqchip/irq-sw64-lpc-intc.c b/drivers/irqchip/irq-sw64-lpc-intc.c
new file mode 100644
index 000000000000..1cbf87478242
--- /dev/null
+++ b/drivers/irqchip/irq-sw64-lpc-intc.c
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/bitops.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/interrupt.h>
+
+#define LPC_NR_IRQS 16
+#define	LPC_IRQ  0x4
+#define	LPC_IRQ_MASK  0x8
+
+struct lpc_intc_data {
+	struct irq_domain *domain;
+	struct irq_chip_generic *gc;
+};
+
+static void lpc_irq_mask_ack(struct irq_data *data)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);
+	struct irq_chip_type *ct = irq_data_get_chip_type(data);
+	unsigned int mask = data->mask;
+
+	irq_gc_lock(gc);
+	*ct->mask_cache |= mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_reg_writel(gc, mask, ct->regs.ack);
+	irq_gc_unlock(gc);
+}
+
+static void lpc_irq_handler(struct irq_desc *desc)
+{
+	struct lpc_intc_data *b = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned int irq;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+
+	status = irq_reg_readl(b->gc, LPC_IRQ);
+
+	if (status == 0) {
+		raw_spin_lock(&desc->lock);
+		handle_bad_irq(desc);
+		raw_spin_unlock(&desc->lock);
+		goto out;
+	}
+
+	while (status) {
+		irq = __ffs(status);
+		status &= ~BIT(irq);
+		generic_handle_irq(irq_find_mapping(b->domain, irq));
+	}
+
+out:
+	chained_irq_exit(chip, desc);
+}
+
+static int __init lpc_intc_of_init(struct device_node *np,
+				  struct device_node *parent)
+{
+	unsigned int set = IRQ_NOPROBE | IRQ_LEVEL;
+	struct lpc_intc_data *data;
+	struct irq_chip_type *ct;
+	int parent_irq, ret;
+	void __iomem *base;
+	int hwirq = 0;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_err("failed to remap lpc intc registers\n");
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	parent_irq = irq_of_parse_and_map(np, 0);
+	if (!parent_irq) {
+		pr_err("failed to find parent interrupt\n");
+		ret = -EINVAL;
+		goto out_unmap;
+	}
+
+	data->domain = irq_domain_add_linear(np, LPC_NR_IRQS,
+				&irq_generic_chip_ops, NULL);
+	if (!data->domain) {
+		ret = -ENOMEM;
+		goto out_unmap;
+	}
+
+	/* Allocate a single Generic IRQ chip for this node */
+	ret = irq_alloc_domain_generic_chips(data->domain, 16, 1, np->name,
+					     handle_level_irq, 0, set,
+					     IRQ_GC_INIT_MASK_CACHE);
+	if (ret) {
+		pr_err("failed to allocate generic irq chip\n");
+		goto out_free_domain;
+	}
+
+	/* Set the IRQ chaining logic */
+	irq_set_chained_handler_and_data(parent_irq,
+					 lpc_irq_handler, data);
+
+	data->gc = irq_get_domain_generic_chip(data->domain, 0);
+	data->gc->reg_base = base;
+	data->gc->private = data;
+
+	ct = data->gc->chip_types;
+
+	ct->regs.ack = LPC_IRQ;
+	ct->regs.mask = LPC_IRQ_MASK;
+	ct->chip.irq_mask = irq_gc_mask_set_bit;
+	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
+	ct->chip.irq_ack = irq_gc_ack_set_bit;
+	ct->chip.irq_mask_ack = lpc_irq_mask_ack;
+
+	for (hwirq = 0 ; hwirq < 16 ; hwirq++)
+		irq_create_mapping(data->domain, hwirq);
+
+	/* Enable LPC interrupts */
+	writel(0xffffebdd, base + LPC_IRQ_MASK);
+
+	return 0;
+
+out_free_domain:
+	irq_domain_remove(data->domain);
+out_unmap:
+	iounmap(base);
+out_free:
+	kfree(data);
+	return ret;
+}
+IRQCHIP_DECLARE(sw_lpc_intc, "sw64,lpc_intc", lpc_intc_of_init);
-- 
2.33.0

