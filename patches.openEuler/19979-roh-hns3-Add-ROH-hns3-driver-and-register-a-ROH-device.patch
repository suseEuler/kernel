From a5742753626694818deac2df13ef435af5f72005 Mon Sep 17 00:00:00 2001
From: Ke Chen <chenke54@huawei.com>
Date: Mon, 7 Nov 2022 19:53:06 +0800
Subject: [PATCH] roh/hns3: Add ROH hns3 driver and register a ROH device
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: a5742753626694818deac2df13ef435af5f72005
Modified-by-SEL: No


driver inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5WKYW

-----------------------------------------------------------------------

These are the source code files for the Hisilicon
ROH driver for ARM, include:
1. hns3_roh_device instance initialization and
   uninitialization.
2. apply for a ROH device to register with the
   ROH core, deregister and release the ROH device
   from ROH Core.

Signed-off-by: Ke Chen <chenke54@huawei.com>
Reviewed-by: Gang Zhang <gang.zhang@huawei.com>
Reviewed-by: Yefeng Yan <yanyefeng@huawei.com>
Reviewed-by: Jingchao Dai <daijingchao1@huawei.com>
Reviewed-by: Jian Shen <shenjian15@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/arm64/configs/openeuler_defconfig |   2 +
 drivers/roh/Kconfig                    |   8 +-
 drivers/roh/Makefile                   |   1 +
 drivers/roh/core/core.c                |   2 +-
 drivers/roh/core/main.c                |   2 +-
 drivers/roh/hw/Makefile                |   3 +
 drivers/roh/hw/hns3/Kconfig            |  12 ++
 drivers/roh/hw/hns3/Makefile           |  11 ++
 drivers/roh/hw/hns3/hns3_common.h      |  46 ++++++
 drivers/roh/hw/hns3/hns3_main.c        | 197 +++++++++++++++++++++++++
 10 files changed, 281 insertions(+), 3 deletions(-)
 create mode 100644 drivers/roh/hw/Makefile
 create mode 100644 drivers/roh/hw/hns3/Kconfig
 create mode 100644 drivers/roh/hw/hns3/Makefile
 create mode 100644 drivers/roh/hw/hns3/hns3_common.h
 create mode 100644 drivers/roh/hw/hns3/hns3_main.c

diff --git a/arch/arm64/configs/openeuler_defconfig b/arch/arm64/configs/openeuler_defconfig
index 3d7e0e44358d..c6c3df7a0459 100644
--- a/arch/arm64/configs/openeuler_defconfig
+++ b/arch/arm64/configs/openeuler_defconfig
@@ -6144,6 +6144,8 @@ CONFIG_TEE=m
 # CONFIG_INTERCONNECT is not set
 # CONFIG_COUNTER is not set
 # CONFIG_MOST is not set
+CONFIG_ROH=m
+CONFIG_ROH_HNS=m
 # end of Device Drivers
 
 #
diff --git a/drivers/roh/Kconfig b/drivers/roh/Kconfig
index 0ff2de261827..af42314b620d 100644
--- a/drivers/roh/Kconfig
+++ b/drivers/roh/Kconfig
@@ -9,8 +9,14 @@ menuconfig ROH
 	select IRQ_POLL
 	select DIMLIB
 	help
-	  Core support for ROH.  Make sure to also select
+	  Core support for ROH. Make sure to also select
 	  any protocols you wish to use as well as drivers
 	  for your ROH hardware.
 
 	  To compile ROH core as module, choose M here.
+
+if ROH
+
+source "drivers/roh/hw/hns3/Kconfig"
+
+endif # ROH
diff --git a/drivers/roh/Makefile b/drivers/roh/Makefile
index e5ea16bd6b21..8b2598e2de8e 100644
--- a/drivers/roh/Makefile
+++ b/drivers/roh/Makefile
@@ -4,3 +4,4 @@
 #
 
 obj-$(CONFIG_ROH)		+= core/
+obj-$(CONFIG_ROH)		+= hw/
diff --git a/drivers/roh/core/core.c b/drivers/roh/core/core.c
index 39c1404e0d97..2883d605e9bc 100644
--- a/drivers/roh/core/core.c
+++ b/drivers/roh/core/core.c
@@ -464,7 +464,7 @@ int roh_core_init(void)
 
 	ret = class_register(&roh_class);
 	if (ret) {
-		pr_err("roh_core: couldn't create roh device class.\n");
+		pr_err("roh_core: couldn't create roh device class, ret = %d\n", ret);
 		return ret;
 	}
 
diff --git a/drivers/roh/core/main.c b/drivers/roh/core/main.c
index 0f766f85eaf5..b9c6a75dd10b 100644
--- a/drivers/roh/core/main.c
+++ b/drivers/roh/core/main.c
@@ -12,7 +12,7 @@ static int __init roh_init(void)
 
 	ret = roh_core_init();
 	if (ret) {
-		pr_err("roh_core: roh core init failed.\n");
+		pr_err("roh_core: roh core init failed, ret = %d\n", ret);
 		return ret;
 	}
 
diff --git a/drivers/roh/hw/Makefile b/drivers/roh/hw/Makefile
new file mode 100644
index 000000000000..e6f0e2a8825c
--- /dev/null
+++ b/drivers/roh/hw/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_ROH_HNS) += hns3/
\ No newline at end of file
diff --git a/drivers/roh/hw/hns3/Kconfig b/drivers/roh/hw/hns3/Kconfig
new file mode 100644
index 000000000000..79d14a30f833
--- /dev/null
+++ b/drivers/roh/hw/hns3/Kconfig
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0+
+config ROH_HNS
+	tristate "HNS ROH Driver"
+	depends on NET_VENDOR_HISILICON
+	depends on ARM64
+	depends on PCI && HNS3
+	help
+	  This is a ROH driver for the Hisilicon ROH engine. The engine
+	  is used in Hisilicon Hip09 and more further ICT SoC based on
+	  PCI device.
+
+	  To compile HIP09 driver as module, choose M here.
diff --git a/drivers/roh/hw/hns3/Makefile b/drivers/roh/hw/hns3/Makefile
new file mode 100644
index 000000000000..d903762b2e0d
--- /dev/null
+++ b/drivers/roh/hw/hns3/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Makefile for the Hisilicon ROH hns3 device drivers.
+#
+
+ccflags-y :=  -I $(srctree)/drivers/net/ethernet/hisilicon/hns3
+ccflags-y +=  -I $(srctree)/drivers/roh/core
+ccflags-y +=  -I $(srctree)/drivers/roh/hw/hns3
+
+hns-roh-v1-objs := hns3_main.o
+obj-$(CONFIG_ROH_HNS) += hns-roh-v1.o
diff --git a/drivers/roh/hw/hns3/hns3_common.h b/drivers/roh/hw/hns3/hns3_common.h
new file mode 100644
index 000000000000..707885e734fc
--- /dev/null
+++ b/drivers/roh/hw/hns3/hns3_common.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+// Copyright (c) 2022 Hisilicon Limited.
+#ifndef __HNS3_ROH_COMMON_H__
+#define __HNS3_ROH_COMMON_H__
+
+#include "core.h"
+#include "hnae3.h"
+
+#define HNS3_ROH_VERSION "1.0"
+
+#define HNS3_ROH_NAME "roh"
+
+struct hns3_roh_priv {
+	struct hnae3_handle *handle;
+	unsigned long state;
+};
+
+struct hns3_roh_device {
+	struct roh_device roh_dev;
+	struct pci_dev *pdev;
+	struct device *dev;
+	bool active;
+	struct net_device *netdev;
+
+	u8 __iomem *reg_base;
+	struct hns3_roh_priv *priv;
+};
+
+static inline struct hns3_roh_device *to_hroh_dev(struct roh_device *rohdev)
+{
+	return container_of(rohdev, struct hns3_roh_device, roh_dev);
+}
+
+#define hns3_roh_set_field(origin, mask, shift, val) \
+	do { \
+		(origin) &= (~(mask)); \
+		(origin) |= ((val) << (shift)) & (mask); \
+	} while (0)
+#define hns3_roh_get_field(origin, mask, shift) (((origin) & (mask)) >> (shift))
+
+#define hns3_roh_set_bit(origin, shift, val) \
+	hns3_roh_set_field(origin, 0x1 << (shift), shift, val)
+#define hns3_roh_get_bit(origin, shift) \
+	hns3_roh_get_field(origin, 0x1 << (shift), shift)
+
+#endif
diff --git a/drivers/roh/hw/hns3/hns3_main.c b/drivers/roh/hw/hns3/hns3_main.c
new file mode 100644
index 000000000000..e766b5c5c943
--- /dev/null
+++ b/drivers/roh/hw/hns3/hns3_main.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright (c) 2022 Hisilicon Limited.
+
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "core.h"
+#include "hnae3.h"
+#include "hns3_common.h"
+
+static const struct pci_device_id hns3_roh_pci_tbl[] = {
+	{ PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_100G_ROH), 0 },
+	{ PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_200G_ROH), 0 },
+	{ PCI_VDEVICE(HUAWEI, HNAE3_DEV_ID_400G_ROH), 0 },
+	{
+		0,
+	}
+};
+MODULE_DEVICE_TABLE(pci, hns3_roh_pci_tbl);
+
+static void hns3_roh_unregister_device(struct hns3_roh_device *hroh_dev)
+{
+	hroh_dev->active = false;
+	roh_unregister_device(&hroh_dev->roh_dev);
+}
+
+static int hns3_roh_register_device(struct hns3_roh_device *hroh_dev)
+{
+	struct roh_device *rohdev = &hroh_dev->roh_dev;
+	struct device *dev = hroh_dev->dev;
+	int ret;
+
+	if (!strlen(rohdev->name))
+		strlcpy(rohdev->name, "hns3_%d", ROH_DEVICE_NAME_MAX);
+
+	rohdev->owner = THIS_MODULE;
+	rohdev->dev.parent = dev;
+	rohdev->netdev = hroh_dev->netdev;
+
+	ret = roh_register_device(rohdev);
+	if (ret) {
+		dev_err(dev, "failed to register roh device, ret = %d\n", ret);
+		return ret;
+	}
+
+	hroh_dev->active = true;
+
+	return 0;
+}
+
+static int hns3_roh_init(struct hns3_roh_device *hroh_dev)
+{
+	struct device *dev = hroh_dev->dev;
+	int ret;
+
+	ret = hns3_roh_register_device(hroh_dev);
+	if (ret) {
+		dev_err(dev, "failed to register roh device, ret = %d\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "%s driver init success.\n", HNS3_ROH_NAME);
+
+	return 0;
+}
+
+static void hns3_roh_exit(struct hns3_roh_device *hroh_dev)
+{
+	hns3_roh_unregister_device(hroh_dev);
+
+	dev_info(&hroh_dev->pdev->dev,
+		 "%s driver uninit success.\n", HNS3_ROH_NAME);
+}
+
+static void hns3_roh_get_cfg_from_frame(struct hns3_roh_device *hroh_dev,
+					struct hnae3_handle *handle)
+{
+	hroh_dev->pdev = handle->pdev;
+	hroh_dev->dev = &handle->pdev->dev;
+
+	hroh_dev->netdev = handle->rohinfo.netdev;
+	hroh_dev->reg_base = handle->rohinfo.roh_io_base;
+
+	hroh_dev->priv->handle = handle;
+}
+
+static int __hns3_roh_init_instance(struct hnae3_handle *handle)
+{
+	struct hns3_roh_device *hroh_dev;
+	int ret;
+
+	hroh_dev = (struct hns3_roh_device *)roh_alloc_device(sizeof(*hroh_dev));
+	if (!hroh_dev) {
+		dev_err(&handle->pdev->dev, "failed to alloc roh dev.\n");
+		return -ENOMEM;
+	}
+
+	hroh_dev->priv = kzalloc(sizeof(*hroh_dev->priv), GFP_KERNEL);
+	if (!hroh_dev->priv) {
+		ret = -ENOMEM;
+		goto err_roh_alloc_device;
+	}
+
+	hns3_roh_get_cfg_from_frame(hroh_dev, handle);
+
+	ret = hns3_roh_init(hroh_dev);
+	if (ret) {
+		dev_err(hroh_dev->dev, "failed to init roh, ret = %d\n", ret);
+		goto err_kzalloc;
+	}
+	handle->priv = hroh_dev;
+
+	return 0;
+
+err_kzalloc:
+	kfree(hroh_dev->priv);
+err_roh_alloc_device:
+	roh_dealloc_device(&hroh_dev->roh_dev);
+	return ret;
+}
+
+static void __hns3_roh_uninit_instance(struct hnae3_handle *handle)
+{
+	struct hns3_roh_device *hroh_dev = (struct hns3_roh_device *)handle->priv;
+
+	if (!hroh_dev)
+		return;
+
+	handle->priv = NULL;
+
+	hns3_roh_exit(hroh_dev);
+
+	kfree(hroh_dev->priv);
+
+	roh_dealloc_device(&hroh_dev->roh_dev);
+}
+
+static int hns3_roh_init_instance(struct hnae3_handle *handle)
+{
+	struct device *dev = &handle->pdev->dev;
+	const struct pci_device_id *id;
+	int ret;
+
+	id = pci_match_id(hns3_roh_pci_tbl, handle->pdev);
+	if (!id) {
+		dev_err(dev, "failed to match pci id.\n");
+		return 0;
+	}
+
+	if (id->driver_data) {
+		dev_err(dev, "not support vf.\n");
+		return -EINVAL;
+	}
+
+	ret = __hns3_roh_init_instance(handle);
+	if (ret) {
+		dev_err(dev, "failed to init instance, ret = %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void hns3_roh_uninit_instance(struct hnae3_handle *handle, bool reset)
+{
+	__hns3_roh_uninit_instance(handle);
+}
+
+static const struct hnae3_client_ops hns3_roh_ops = {
+	.init_instance = hns3_roh_init_instance,
+	.uninit_instance = hns3_roh_uninit_instance,
+};
+
+static struct hnae3_client hns3_roh_client = {
+	.name = "hns3_roh_hw",
+	.type = HNAE3_CLIENT_ROH,
+	.ops = &hns3_roh_ops,
+};
+
+static int __init hns3_roh_module_init(void)
+{
+	return hnae3_register_client(&hns3_roh_client);
+}
+
+static void __exit hns3_roh_module_cleanup(void)
+{
+	hnae3_unregister_client(&hns3_roh_client);
+}
+
+module_init(hns3_roh_module_init);
+module_exit(hns3_roh_module_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION(HNS3_ROH_VERSION);
+MODULE_AUTHOR("Huawei Tech. Co., Ltd.");
+MODULE_DESCRIPTION("Hisilicon Hip09 Family ROH Driver");
-- 
2.33.0

