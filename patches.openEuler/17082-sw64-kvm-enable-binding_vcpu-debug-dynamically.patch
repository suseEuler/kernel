From d14ec0e7e888b5ab16142e0a71da4d99183587b6 Mon Sep 17 00:00:00 2001
From: Wang Yuanheng <wangyuanheng@wxiat.com>
Date: Mon, 27 Jun 2022 09:02:01 +0800
Subject: [PATCH] sw64: kvm: enable binding_vcpu debug dynamically
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: d14ec0e7e888b5ab16142e0a71da4d99183587b6
Modified-by-SEL: No


Sunway inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5GFR5

--------------------------------

Add a bool debugfs file /sys/kernel/debug/sw_64/bind_vcpu, you can
echo 1/Y to enable bind vcpu, or echo 0/N to disable it. Determin which
node to bind the core according to the physical address assigned to the
guest.

Signed-off-by: Wang Yuanheng <wangyuanheng@wxiat.com>

Signed-off-by: Gu Zitao <guzitao@wxiat.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/sw_64/kernel/Makefile   |  2 +-
 arch/sw_64/kernel/bindvcpu.c | 29 +++++++++++++++++++++++++++++
 arch/sw_64/kvm/kvm-sw64.c    | 13 ++++++++++++-
 3 files changed, 42 insertions(+), 2 deletions(-)
 create mode 100644 arch/sw_64/kernel/bindvcpu.c

diff --git a/arch/sw_64/kernel/Makefile b/arch/sw_64/kernel/Makefile
index 94b63d6a286b..d4dc9e175d67 100644
--- a/arch/sw_64/kernel/Makefile
+++ b/arch/sw_64/kernel/Makefile
@@ -31,7 +31,7 @@ obj-$(CONFIG_HIBERNATION) += hibernate_asm.o hibernate.o
 obj-$(CONFIG_AUDIT)     += audit.o
 obj-$(CONFIG_PCI) += pci_common.o
 obj-$(CONFIG_RELOCATABLE)   += relocate.o
-obj-$(CONFIG_DEBUG_FS)	+= segvdbg.o
+obj-$(CONFIG_DEBUG_FS)	+= segvdbg.o bindvcpu.o
 obj-$(CONFIG_JUMP_LABEL) += jump_label.o
 
 ifndef CONFIG_PCI
diff --git a/arch/sw_64/kernel/bindvcpu.c b/arch/sw_64/kernel/bindvcpu.c
new file mode 100644
index 000000000000..611c395c144b
--- /dev/null
+++ b/arch/sw_64/kernel/bindvcpu.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 Wang Yuanheng
+ * Author: Wang Yuanheng
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <asm/debug.h>
+
+extern bool bind_vcpu_enabled;
+
+static int __init bind_vcpu_init(void)
+{
+	struct dentry *bindvcpu;
+
+	if (!sw64_debugfs_dir)
+		return -ENODEV;
+
+	bindvcpu = debugfs_create_bool("bind_vcpu", 0644,
+			sw64_debugfs_dir, &bind_vcpu_enabled);
+	if (!bindvcpu)
+		return -ENOMEM;
+	return 0;
+}
+late_initcall(bind_vcpu_init);
diff --git a/arch/sw_64/kvm/kvm-sw64.c b/arch/sw_64/kvm/kvm-sw64.c
index af29d0ca8e7f..de81f7efe01a 100644
--- a/arch/sw_64/kvm/kvm-sw64.c
+++ b/arch/sw_64/kvm/kvm-sw64.c
@@ -12,7 +12,7 @@
 #include <linux/sched/signal.h>
 #include <linux/kvm.h>
 #include <linux/uaccess.h>
-
+#include <linux/sched.h>
 #include <asm/kvm_timer.h>
 #include <asm/kvm_emulate.h>
 
@@ -21,6 +21,7 @@
 
 bool set_msi_flag;
 unsigned long sw64_kvm_last_vpn[NR_CPUS];
+__read_mostly bool bind_vcpu_enabled;
 #define cpu_last_vpn(cpuid) sw64_kvm_last_vpn[cpuid]
 
 #ifdef CONFIG_SUBARCH_C3B
@@ -537,6 +538,16 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 #ifndef CONFIG_KVM_MEMHOTPLUG
 		vcpu->arch.vcb.vpcr
 			= get_vpcr(vcpu->kvm->arch.host_phys_addr, vcpu->kvm->arch.size, 0);
+
+		if (unlikely(bind_vcpu_enabled)) {
+			int nid;
+			unsigned long end;
+
+			end = vcpu->kvm->arch.host_phys_addr + vcpu->kvm->arch.size;
+			nid = pfn_to_nid(PHYS_PFN(vcpu->kvm->arch.host_phys_addr));
+			if (pfn_to_nid(PHYS_PFN(end)) == nid)
+				set_cpus_allowed_ptr(vcpu->arch.tsk, node_to_cpumask_map[nid]);
+		}
 #else
 		unsigned long seg_base = virt_to_phys(vcpu->kvm->arch.seg_pgd);
 
-- 
2.33.0

