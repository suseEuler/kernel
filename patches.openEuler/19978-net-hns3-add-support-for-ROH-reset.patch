From 261b9bc3759795c5031d95218788fb8cd828ff71 Mon Sep 17 00:00:00 2001
From: Ke Chen <chenke54@huawei.com>
Date: Mon, 7 Nov 2022 19:53:05 +0800
Subject: [PATCH] net: hns3: add support for ROH reset
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 261b9bc3759795c5031d95218788fb8cd828ff71
Modified-by-SEL: No


driver inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5WKYW

-----------------------------------------------------------------------

Adds ROH reset support for HNS3 ethernet driver.

Signed-off-by: Yufeng Mo <moyufeng@huawei.com>
Signed-off-by: Ke Chen <chenke54@huawei.com>
Reviewed-by: Gang Zhang <gang.zhang@huawei.com>
Reviewed-by: Yefeng Yan <yanyefeng@huawei.com>
Reviewed-by: Jingchao Dai <daijingchao1@huawei.com>
Reviewed-by: Jian Shen <shenjian15@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 drivers/net/ethernet/hisilicon/hns3/hnae3.h   |  1 +
 .../hisilicon/hns3/hns3pf/hclge_main.c        | 42 +++++++++++++++++++
 2 files changed, 43 insertions(+)

diff --git a/drivers/net/ethernet/hisilicon/hns3/hnae3.h b/drivers/net/ethernet/hisilicon/hns3/hnae3.h
index c2248c516bf9..cedcac37145a 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hnae3.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hnae3.h
@@ -841,6 +841,7 @@ struct hnae3_roh_private_info {
 	struct net_device *netdev;
 	void __iomem *roh_io_base;
 	int base_vector;
+	unsigned long reset_state;
 };
 
 #define HNAE3_SUPPORT_APP_LOOPBACK    BIT(0)
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index fb357c32cd44..823c6ea7b0e0 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -3714,6 +3714,28 @@ static int hclge_notify_roce_client(struct hclge_dev *hdev,
 	return ret;
 }
 
+static int hclge_notify_roh_client(struct hclge_dev *hdev,
+				   enum hnae3_reset_notify_type type)
+{
+	struct hnae3_handle *handle = &hdev->vport[0].roh;
+	struct hnae3_client *client = hdev->roh_client;
+	int ret;
+
+	if (!test_bit(HCLGE_STATE_ROH_REGISTERED, &hdev->state) || !client)
+		return 0;
+
+	if (!client->ops->reset_notify)
+		return -EOPNOTSUPP;
+
+	ret = client->ops->reset_notify(handle, type);
+	if (ret)
+		dev_err(&hdev->pdev->dev,
+			"failed to notify roh client type %d, ret = %d\n",
+			type, ret);
+
+	return ret;
+}
+
 static int hclge_reset_wait(struct hclge_dev *hdev)
 {
 #define HCLGE_RESET_WATI_MS	100
@@ -4234,6 +4256,10 @@ static int hclge_reset_prepare(struct hclge_dev *hdev)
 	if (ret)
 		return ret;
 
+	ret = hclge_notify_roh_client(hdev, HNAE3_DOWN_CLIENT);
+	if (ret)
+		return ret;
+
 	rtnl_lock();
 	ret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);
 	rtnl_unlock();
@@ -4253,6 +4279,10 @@ static int hclge_reset_rebuild(struct hclge_dev *hdev)
 	if (ret)
 		return ret;
 
+	ret = hclge_notify_roh_client(hdev, HNAE3_UNINIT_CLIENT);
+	if (ret)
+		return ret;
+
 	rtnl_lock();
 	ret = hclge_reset_stack(hdev);
 	rtnl_unlock();
@@ -4269,6 +4299,14 @@ static int hclge_reset_rebuild(struct hclge_dev *hdev)
 	    hdev->rst_stats.reset_fail_cnt < HCLGE_RESET_MAX_FAIL_CNT - 1)
 		return ret;
 
+	ret = hclge_notify_roh_client(hdev, HNAE3_INIT_CLIENT);
+	/* ignore ROH notify error if it fails HCLGE_RESET_MAX_FAIL_CNT - 1
+	 * times
+	 */
+	if (ret &&
+	    hdev->rst_stats.reset_fail_cnt < HCLGE_RESET_MAX_FAIL_CNT - 1)
+		return ret;
+
 	ret = hclge_reset_prepare_up(hdev);
 	if (ret)
 		return ret;
@@ -4283,6 +4321,10 @@ static int hclge_reset_rebuild(struct hclge_dev *hdev)
 	if (ret)
 		return ret;
 
+	ret = hclge_notify_roh_client(hdev, HNAE3_UP_CLIENT);
+	if (ret)
+		return ret;
+
 	hdev->last_reset_time = jiffies;
 	hdev->rst_stats.reset_fail_cnt = 0;
 	hdev->rst_stats.reset_done_cnt++;
-- 
2.33.0

