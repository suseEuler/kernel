From 7a4a3fd97b1d4af74650a52e18a8eb1c222e97bc Mon Sep 17 00:00:00 2001
From: Chen Hui <judy.chenhui@huawei.com>
Date: Fri, 25 Nov 2022 12:03:58 +0800
Subject: [PATCH] sched: programmable: Add user interface of task group tag
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 7a4a3fd97b1d4af74650a52e18a8eb1c222e97bc
Modified-by-SEL: Yes, refreshed due to different context


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I5KUFB
CVE: NA

--------------------------------

Add user interface of task group tag, bridges the information
gap between user-mode and kernel-mode.

Signed-off-by: Chen Hui <judy.chenhui@huawei.com>
Signed-off-by: Ren Zhijie <renzhijie2@huawei.com>
Signed-off-by: Hui Tang <tanghui20@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 include/linux/sched.h |    4 ++
 kernel/sched/core.c   |   81 ++++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/sched/sched.h  |    3 +
 3 files changed, 88 insertions(+)

--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -2216,4 +2216,8 @@ static inline int sched_qos_cpu_overload
 	return 0;
 }
 #endif
+
+#ifdef CONFIG_BPF_SCHED
+extern void sched_settag(struct task_struct *tsk, s64 tag);
+#endif
 #endif
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -9484,6 +9484,80 @@ static inline s64 cpu_qos_read(struct cg
 }
 #endif
 
+#ifdef CONFIG_BPF_SCHED
+void sched_settag(struct task_struct *tsk, s64 tag)
+{
+	int queued, running, queue_flags =
+			DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
+	struct rq_flags rf;
+	struct rq *rq;
+
+	if (tsk->tag == tag)
+		return;
+
+	rq = task_rq_lock(tsk, &rf);
+
+	running = task_current(rq, tsk);
+	queued = task_on_rq_queued(tsk);
+
+	update_rq_clock(rq);
+	if (queued)
+		dequeue_task(rq, tsk, queue_flags);
+	if (running)
+		put_prev_task(rq, tsk);
+
+	tsk->tag = tag;
+
+	if (queued)
+		enqueue_task(rq, tsk, queue_flags);
+	if (running)
+		set_next_task(rq, tsk);
+
+	task_rq_unlock(rq, tsk, &rf);
+}
+
+int tg_change_tag(struct task_group *tg, void *data)
+{
+	struct css_task_iter it;
+	struct task_struct *tsk;
+	s64 tag = *(s64 *)data;
+	struct cgroup_subsys_state *css = &tg->css;
+
+	tg->tag = tag;
+
+	css_task_iter_start(css, 0, &it);
+	while ((tsk = css_task_iter_next(&it)))
+		sched_settag(tsk, tag);
+	css_task_iter_end(&it);
+
+	return 0;
+}
+
+static int cpu_tag_write(struct cgroup_subsys_state *css,
+			 struct cftype *cftype, s64 tag)
+{
+	struct task_group *tg = css_tg(css);
+
+	if (tg == &root_task_group)
+		return -EINVAL;
+
+	if (tg->tag == tag)
+		return 0;
+
+	rcu_read_lock();
+	walk_tg_tree_from(tg, tg_change_tag, tg_nop, (void *)(&tag));
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static inline s64 cpu_tag_read(struct cgroup_subsys_state *css,
+			 struct cftype *cft)
+{
+	return css_tg(css)->tag;
+}
+#endif
+
 static struct cftype cpu_legacy_files[] = {
 #ifdef CONFIG_FAIR_GROUP_SCHED
 	{
@@ -9546,6 +9620,13 @@ static struct cftype cpu_legacy_files[]
 		.write_s64 = cpu_qos_write,
 	},
 #endif
+#ifdef CONFIG_BPF_SCHED
+	{
+		.name = "tag",
+		.read_s64 = cpu_tag_read,
+		.write_s64 = cpu_tag_write,
+	},
+#endif
 	{ }	/* Terminate */
 };
 
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -494,6 +494,9 @@ static inline int walk_tg_tree(tg_visito
 }
 
 extern int tg_nop(struct task_group *tg, void *data);
+#ifdef CONFIG_BPF_SCHED
+extern int tg_change_tag(struct task_group *tg, void *data);
+#endif
 
 extern void free_fair_sched_group(struct task_group *tg);
 extern int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent);
