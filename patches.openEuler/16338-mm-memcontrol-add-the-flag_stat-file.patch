From 5cda4079baaeb7dc8b04568cc4996b512fb8abf3 Mon Sep 17 00:00:00 2001
From: tatataeki <shengzeyu19_98@163.com>
Date: Wed, 22 Jun 2022 14:41:29 +0800
Subject: [PATCH] mm: memcontrol: add the flag_stat file
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 5cda4079baaeb7dc8b04568cc4996b512fb8abf3
Modified-by-SEL: No


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I4MC3F
CVE: NA

----------------------------------

Multiple operations on cgroups in cgroup v1 are related to the status
of the cgroup. The status of the current cgroup can be displayed in
cgroupv2, but it cannot be displayed in cgroup v1, so the
cgroup.flag_stat member is added in memory cgroup to display the
status of the current cgroup and sub-cgroups.

Testing result:
List the status of user.slice
[root@test user.slice]#cat memory.flag_stat
NO_REF 0
ONLINE 1
RELEASED 0
VISIBLE 1
DYING 0
CHILD_NO_REF 0
CHILD_ONLINE 1
CHILD_RELEASED 0
CHILD_VISIBLE 1
CHILD_DYING 0

Create a new cgroup in user.slice
[root@test user.slice]#mkdir user-test

List the current status of user.slice after operation above
[root@test user.slice]#cat memory.flag_stat
NO_REF 0
ONLINE 1
RELEASED 0
VISIBLE 1
DYING 0
CHILD_NO_REF 0
CHILD_ONLINE 2
CHILD_RELEASED 0
CHILD_VISIBLE 2
CHILD_DYING 0

Signed-off-by: tatataeki <shengzeyu19_98@163.com>
Reviewed-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Reviewed-by: Xiu Jianfeng <xiujianfeng@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 mm/memcontrol.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 3ede56d6b307..1938e69ad5cc 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -4556,6 +4556,53 @@ static void mem_cgroup_oom_unregister_event(struct mem_cgroup *memcg,
 	spin_unlock(&memcg_oom_lock);
 }
 
+static const char *const memcg_flag_name[] = {
+	"NO_REF",
+	"ONLINE",
+	"RELEASED",
+	"VISIBLE",
+	"DYING"
+};
+
+static void memcg_flag_stat_get(int mem_flags, int *stat)
+{
+	int i;
+	int flags = mem_flags;
+
+	for (i = 0; i < ARRAY_SIZE(memcg_flag_name); i++) {
+		if (flags & 1)
+			stat[i] += 1;
+		flags >>= 1;
+	}
+}
+
+static int memcg_flag_stat_show(struct seq_file *sf, void *v)
+{
+	int self_flag[ARRAY_SIZE(memcg_flag_name)];
+	int child_flag[ARRAY_SIZE(memcg_flag_name)];
+	int iter;
+	struct cgroup_subsys_state *child;
+	struct cgroup_subsys_state *css = seq_css(sf);
+
+	memset(self_flag, 0, sizeof(self_flag));
+	memset(child_flag, 0, sizeof(child_flag));
+
+	memcg_flag_stat_get(css->flags, self_flag);
+
+	rcu_read_lock();
+	css_for_each_child(child, css)
+		memcg_flag_stat_get(child->flags, child_flag);
+	rcu_read_unlock();
+
+	for (iter = 0; iter < ARRAY_SIZE(memcg_flag_name); iter++)
+		seq_printf(sf, "%s %d\n", memcg_flag_name[iter], self_flag[iter]);
+
+	for (iter = 0; iter < ARRAY_SIZE(memcg_flag_name); iter++)
+		seq_printf(sf, "CHILD_%s %d\n", memcg_flag_name[iter], child_flag[iter]);
+
+	return 0;
+}
+
 static int mem_cgroup_oom_control_read(struct seq_file *sf, void *v)
 {
 	struct mem_cgroup *memcg = mem_cgroup_from_seq(sf);
@@ -5259,6 +5306,10 @@ static struct cftype mem_cgroup_legacy_files[] = {
 		.write_u64 = mem_cgroup_oom_control_write,
 		.private = MEMFILE_PRIVATE(_OOM_TYPE, OOM_CONTROL),
 	},
+	{
+		.name = "flag_stat",
+		.seq_show = memcg_flag_stat_show,
+	},
 	{
 		.name = "pressure_level",
 	},
-- 
2.33.0

